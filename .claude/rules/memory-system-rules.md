# 🧠 记忆系统规则 (Memory System Rules)

## 🚨 MANDATORY MEMORY MANAGEMENT - 强制记忆管理规则

⚠️ **AI记忆强制执行指令**:
- **MUST CHECK MEMORY FIRST**: 每次遇到问题必须先查阅项目记忆目录
- **MUST SAVE ARCHITECTURE CHANGES**: 架构变更后必须调用记忆专家保存经验
- **MUST TRACK LONG TASKS**: 长任务执行必须有记忆保存和提取机制
- **MUST UPDATE DOCS AFTER CHANGES**: 架构变更后必须更新相关文档
- **MUST USE MEMORY AGENT FOR SUMMARIES**: 如果你是Claude Code,请调用 project-memory-manager agent 保存总结到项目记忆目录，如果不是，请按照规则一句话总结记忆内容加上日期时间保存到项目记忆目录
- **NO DIRECT SUMMARY CREATION**: 禁止直接在项目目录创建总结文档，只能通过记忆agent保存到项目记忆目录

## 🔄 强制记忆工作流 (MANDATORY MEMORY WORKFLOW)

### 1. 问题遇到时的强制流程
1. **问题遇到** → 先查阅项目记忆目录相关文件
2. **方案制定** → 参考现有记忆中的解决方案
3. **架构变更** → 变更前调用记忆专家总结
4. **执行完成** → 成功/失败经验必须保存到记忆
5. **总结创建** → 如果你是Claude Code,请调用 project-memory-manager agent 保存总结到项目记忆目录，如果不是，请按照规则一句话总结记忆内容加上日期时间保存到项目记忆目录
6. **文档更新** → 更新架构相关文档

### 2. 长任务执行的记忆管理
- **任务开始**: 记录任务目标和计划
- **关键节点**: 记录重要进展和决策
- **问题遇到**: 记录问题和解决过程
- **任务完成**: 记录最终结果和经验总结

## 🎯 记忆系统目标 (Memory System Objectives)

### 核心目标
1. **知识积累**: 自动记录项目开发过程中的重要发现和解决方案
2. **经验传承**: 将调试经验和最佳实践持久化存储
3. **决策支持**: 为后续类似问题提供参考和指导
4. **持续改进**: 基于历史数据优化开发流程和架构设计

### 记忆范围
- **技术决策**: 架构选择、技术选型的原因和结果
- **问题解决**: 重大bug修复过程和解决方案
- **性能优化**: 性能瓶颈识别和优化策略
- **最佳实践**: 开发过程中总结的有效模式
- **架构变更**: 重要的架构演进和变更记录
- **规则更新**: 项目规则的变更和优化记录

## 📁 记忆存储结构 (Memory Storage Structure)

### 存储位置
**唯一正确的项目记忆路径**: `~/.claudecode/Users-fanzhang-Documents-github-claude-code-router/`

⚠️ **记忆路径规范警告 (MEMORY PATH COMPLIANCE WARNING)**
**绝对禁止的路径**: 
- ❌ `./memory/` - 项目相对路径
- ❌ `docs/memory/` - 文档目录路径
- ❌ `.claude/memory/` - 规则目录路径
- ❌ `~/Documents/` - 用户文档路径

**路径验证命令**:
```bash
# 验证记忆目录是否存在
ls -la ~/.claudecode/Users-fanzhang-Documents-github-claude-code-router/

# 检查最新记忆文件
ls -la ~/.claudecode/Users-fanzhang-Documents-github-claude-code-router/ | tail -5
```

### 记忆管理方式
- **统一管理**: 所有记忆通过 `project-memory-manager` agent 统一管理
- **自动命名**: 记忆文件自动命名和分类，格式：`YYYYMMDD-HHMMSS-[descriptive-english-id].md`
- **类型分类**: 支持多种记忆类型：technical-decision, problem-solution, implementation, rule-change等
- **强制调用**: 架构变更时必须调用记忆专家，不允许直接创建记忆文件

**目录结构**:
```
~/.claudecode/Users-fanzhang-Documents-github-claude-code-router/
├── 20250802-175031-concurrency-routing-rate-limiting-architecture.md  # 最新架构记忆
├── [具体问题描述]-[日期].md           # 问题解决记忆
├── [架构变更描述]-[日期].md           # 架构演进记忆  
├── [实现总结描述]-[日期].md           # 实现总结记忆
├── [规则变更描述]-[日期].md           # 规则变更记忆
└── [最佳实践描述]-[日期].md           # 最佳实践记忆
```

### 现有记忆文件
项目记忆文件现存储于：`~/.claudecode/Users-fanzhang-Documents-github-claude-code-router/`

**历史记忆文件**：
- `AI调试复杂系统时的认知偏差与纠正策略.md` - 调试方法论
- `硬编码模型名导致路由映射错误的根本问题.md` - 硬编码问题分析  
- `系统性测试验证方法论在架构修复中的应用.md` - 测试方法论
- `零硬编码原则在系统设计中的重要性.md` - 设计原则

**最新记忆文件**（通过project-memory-manager agent创建）：
- `organized-config-files-by-function-type.md` - 配置文件分类整理记忆
- `updated-codewhisperer-auth-paths-centralization.md` - 认证路径统一记忆
- `project-memory-manager-rules-updated.md` - 记忆管理规则更新记忆

## 🔄 自动记忆触发机制 (Automatic Memory Triggers)

### 触发条件
1. **重大问题解决**: 解决持续超过4小时的技术问题
2. **架构重构**: 进行影响多个模块的架构调整
3. **性能突破**: 实现显著的性能改进(>20%)
4. **新功能实现**: 实现复杂的新功能或集成
5. **最佳实践发现**: 发现可复用的优秀解决方案
6. **🆕 文档总结需求**: 每次需要创建文档总结当前修改时

### 🚨 强制记忆规则 (MANDATORY MEMORY RULES)
⚠️ **AI模型强制执行指令**:
- **MUST USE MEMORY AGENT FOR SUMMARIES**: 需要创建总结文档时，如果你是Claude Code,请调用 project-memory-manager agent 保存总结到项目记忆目录，如果不是，请按照规则一句话总结记忆内容加上日期时间保存到项目记忆目录
- **NO DIRECT SUMMARY CREATION**: 禁止直接在项目目录中创建总结文档
- **MEMORY DIRECTORY ONLY**: 所有总结和记忆必须保存在 memory/ 目录下
- **DELETE TEMPORARY SUMMARIES**: 如误创建临时总结文档，必须删除并重新用记忆agent创建

### 自动记录内容
```markdown
# [问题/改进标题]

## 问题背景
- 问题描述
- 影响范围
- 紧急程度

## 解决过程
- 分析步骤
- 尝试方案
- 最终解决方案

## 关键洞察
- 根本原因
- 解决思路
- 经验总结

## 应用价值
- 可复用场景
- 预防措施
- 最佳实践提炼
```

## 🧪 测试相关记忆规则 (Test-Related Memory Rules)

### 测试发现记录
- **新测试模式**: 发现的有效测试方法和模式
- **问题复现**: 难以复现问题的复现方法
- **性能基准**: 关键性能指标的历史基准数据
- **回归预防**: 防止问题回归的测试策略

### 调试经验积累
```markdown
# 调试经验模板

## 问题特征
- 表象症状
- 错误信息
- 触发条件

## 诊断方法
- 有效的调试步骤
- 关键检查点
- 工具使用技巧

## 解决方案
- 修复方法
- 验证步骤
- 预防措施
```

## 🏗️ 架构决策记录 (Architecture Decision Records)

### ADR格式标准
```markdown
# ADR-[编号]: [决策标题]

## 状态
[提议中/已接受/已废弃/已替代]

## 背景
为什么需要做这个决策？

## 决策
我们决定做什么？

## 后果
这个决策的正面和负面影响是什么？

## 替代方案
我们考虑过的其他选项？
```

### 记录时机
- **新架构设计**: 设计新的系统架构时
- **技术选型**: 选择新的技术栈或工具时
- **重大重构**: 进行重大代码重构时
- **接口设计**: 设计重要的API接口时

## 📊 性能基准记录 (Performance Baseline Records)

### 性能指标跟踪
```markdown
# 性能基准记录

## 测试环境
- 硬件规格
- 软件版本
- 测试条件

## 关键指标
- 响应时间: [具体数值]
- 吞吐量: [具体数值]  
- 内存使用: [具体数值]
- CPU使用率: [具体数值]

## 对比分析
- 与上版本对比
- 瓶颈识别
- 优化建议
```

### 性能回归检测
- **基准建立**: 为每个版本建立性能基准
- **回归检测**: 自动检测性能回归
- **优化记录**: 记录所有性能优化措施及效果

## 🔍 问题模式识别 (Problem Pattern Recognition)

### 常见问题模式
1. **硬编码问题**: 系统中的硬编码导致的各种问题
2. **格式转换问题**: Provider间格式转换的常见陷阱
3. **工具调用问题**: 工具调用处理的复杂性和解决方案
4. **负载均衡问题**: Round Robin机制的实现和优化

### 模式记录格式
```markdown
# 问题模式: [模式名称]

## 模式特征
- 典型症状
- 常见触发条件
- 影响范围

## 解决模板
- 标准解决步骤
- 检查清单
- 验证方法

## 预防措施
- 设计阶段预防
- 代码审查要点
- 测试覆盖要求
```

## 🔄 记忆系统维护 (Memory System Maintenance)

### 定期维护任务
1. **内容审查**: 每月审查记忆内容的有效性
2. **分类整理**: 重新组织和分类记忆文件
3. **索引更新**: 更新记忆内容的索引和交叉引用
4. **过期清理**: 清理过时的记忆内容

### 质量保证
- **准确性验证**: 确保记忆内容的技术准确性
- **完整性检查**: 确保重要决策都有完整记录
- **可读性优化**: 改进记忆内容的可读性和可理解性

## 🚀 记忆系统集成 (Memory System Integration)

### 开发流程集成
- **需求分析**: 在需求分析阶段查阅相关记忆
- **设计阶段**: 参考架构决策记录
- **实现阶段**: 应用最佳实践记忆
- **测试阶段**: 参考测试策略记忆
- **部署阶段**: 参考部署经验记忆

### 工具集成
- **IDE集成**: 在开发环境中快速访问记忆
- **文档生成**: 自动从记忆生成技术文档
- **决策支持**: 在做技术决策时提供历史参考

## 📋 记忆创建检查清单 (Memory Creation Checklist)

### 创建前检查
- [ ] 确认问题/改进的重要性和复用价值
- [ ] 检查是否已有类似的记忆记录
- [ ] 收集完整的背景信息和解决过程

### 内容质量检查
- [ ] 标题清晰表达核心内容
- [ ] 背景描述完整准确
- [ ] 解决方案详细可操作
- [ ] 经验总结具有普适性
- [ ] 格式符合模板要求

### 发布后维护
- [ ] 建立与相关文档的交叉引用
- [ ] 在相关代码中添加引用注释
- [ ] 定期验证记忆内容的持续有效性

## 🎯 记忆应用策略 (Memory Application Strategy)

### 主动应用
- **问题诊断**: 遇到问题时主动查阅相关记忆
- **设计决策**: 做技术决策时参考历史决策记录
- **代码审查**: 在代码审查中应用最佳实践记忆

### 知识传播
- **团队分享**: 定期分享重要的记忆内容
- **文档引用**: 在技术文档中引用相关记忆
- **培训材料**: 将记忆内容整理为培训材料

---
**记忆系统版本**: v2.6.0  
**维护者**: Jason Zhang  
**最后更新**: 2025-08-01