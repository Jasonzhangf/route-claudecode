#!/usr/bin/env node

/**
 * Critical 400 Errors Fix - Database-Driven Mock Test System
 * 
 * Âü∫‰∫éÁúüÂÆûÊï∞ÊçÆÂ∫ìÊ†∑Êú¨ÊûÑÂª∫MockÁ¨¨‰∏âÊñπÊúçÂä°Âô®ËøûÊé•È¢ÑÂ§ÑÁêÜÂô®
 * Êï¥ÈìæË∑ØÂÆåÊï¥ÂìçÂ∫îÔºàÂ§öÂ∑•ÂÖ∑ÊµãËØïÔºâÈ™åËØÅÂÆ¢Êà∑Á´ØËøûÊé•Ê≠£Â∏∏
 * 
 * ÂèëÁé∞ÁöÑÂÖ≥ÈîÆÈóÆÈ¢ò:
 * 1. ToolsÊï∞ÁªÑÊ†ºÂºèÈîôËØØ: "Invalid type for 'tools.14', expected an json object"
 * 2. Messages contentÊ†ºÂºèÈîôËØØ: "expected one of a string or array of objects, but got an object instead"
 * 3. Á≥ªÁªüÊåáÁ§∫Ë¢´ÈîôËØØÂú∞‰º†ÈÄíÂà∞ProviderËÄå‰∏çÊòØ‰Ωú‰∏∫Á≥ªÁªüÊ∂àÊÅØÂ§ÑÁêÜ
 * 
 * Author: Jason Zhang
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

console.log('üö® Critical 400 Errors Fix - Database-Driven Mock Test System');
console.log('=============================================================');

// ÊµãËØïÈÖçÁΩÆ
const TEST_PORT = 3456;
const TIMEOUT = 120000; // 2ÂàÜÈíüË∂ÖÊó∂
const DATABASE_SAMPLES = './database/tool-parsing-failures.json';

let testResults = {
    timestamp: new Date().toISOString(),
    testName: 'Critical 400 Errors Fix - Database-Driven Mock Test',
    problems: [],
    fixes: [],
    validationResults: {},
    overallSuccess: false
};

// üîç ÂàÜÊûêÁúüÂÆûÊï∞ÊçÆÂ∫ìÊ†∑Êú¨
function analyzeDatabaseSamples() {
    console.log('\nüîç Step 1: ÂàÜÊûêÁúüÂÆûÊï∞ÊçÆÂ∫ìÊ†∑Êú¨');
    
    if (!fs.existsSync(DATABASE_SAMPLES)) {
        console.log('‚ùå Êï∞ÊçÆÂ∫ìÊ†∑Êú¨Êñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂàõÂª∫Ê®°ÊãüÊ†∑Êú¨');
        return createMockSamples();
    }
    
    try {
        const samples = JSON.parse(fs.readFileSync(DATABASE_SAMPLES, 'utf8'));
        console.log(`üìä ÂèëÁé∞ ${samples.length} ‰∏™Êï∞ÊçÆÂ∫ìÊ†∑Êú¨`);
        
        // ÂàÜÊûêÂ§±Ë¥•Ê®°Âºè
        const failurePatterns = {};
        const toolsFormatIssues = [];
        const messagesFormatIssues = [];
        
        samples.forEach((sample, index) => {
            // Ê£ÄÊü•Â∑•ÂÖ∑Ë∞ÉÁî®Â§±Ë¥•Ê®°Âºè
            if (sample.failureType) {
                failurePatterns[sample.failureType] = (failurePatterns[sample.failureType] || 0) + 1;
            }
            
            // Ê£ÄÊü•ËØ∑Ê±ÇÂ∑•ÂÖ∑Ê†ºÂºè
            if (sample.debugInfo && sample.debugInfo.requestTools) {
                sample.debugInfo.requestTools.forEach((tool, toolIndex) => {
                    if (!tool.name || !tool.input_schema) {
                        toolsFormatIssues.push({
                            sampleIndex: index,
                            toolIndex,
                            issue: 'Missing name or input_schema',
                            tool: tool
                        });
                    }
                });
            }
        });
        
        console.log('üìã Â§±Ë¥•Ê®°ÂºèÂàÜÊûê:');
        Object.entries(failurePatterns).forEach(([pattern, count]) => {
            console.log(`   ${pattern}: ${count}Ê¨°`);
        });
        
        if (toolsFormatIssues.length > 0) {
            console.log(`‚ö†Ô∏è  ÂèëÁé∞ ${toolsFormatIssues.length} ‰∏™Â∑•ÂÖ∑Ê†ºÂºèÈóÆÈ¢ò`);
            testResults.problems.push({
                type: 'tools_format_issues',
                count: toolsFormatIssues.length,
                samples: toolsFormatIssues.slice(0, 3) // ‰øùÂ≠òÂâç3‰∏™Ê†∑Êú¨
            });
        }
        
        return {
            samples,
            failurePatterns,
            toolsFormatIssues,
            messagesFormatIssues
        };
        
    } catch (error) {
        console.log(`‚ùå Ëß£ÊûêÊï∞ÊçÆÂ∫ìÊ†∑Êú¨Â§±Ë¥•: ${error.message}`);
        return createMockSamples();
    }
}

// üè≠ ÂàõÂª∫Ê®°ÊãüÊ†∑Êú¨ÔºàÂ¶ÇÊûúÊï∞ÊçÆÂ∫ìÊ†∑Êú¨‰∏çÂ≠òÂú®Ôºâ
function createMockSamples() {
    console.log('üè≠ ÂàõÂª∫Ê®°ÊãüÊï∞ÊçÆÂ∫ìÊ†∑Êú¨');
    
    const mockSamples = [
        {
            // Ê≠£Á°ÆÁöÑAnthropicÊ†ºÂºèÊ†∑Êú¨
            timestamp: new Date().toISOString(),
            requestId: 'mock-correct-anthropic-001',
            provider: 'anthropic',
            model: 'claude-3-sonnet-20240229',
            sampleType: 'correct_anthropic_format',
            request: {
                model: 'claude-3-sonnet-20240229',
                messages: [
                    {
                        role: 'user',
                        content: [
                            {
                                type: 'text',
                                text: 'Search for TypeScript files in the current project.'
                            }
                        ]
                    }
                ],
                tools: [
                    {
                        name: 'search_files',
                        description: 'Search for files in the project directory',
                        input_schema: {
                            type: 'object',
                            properties: {
                                pattern: {
                                    type: 'string',
                                    description: 'File pattern to search for'
                                }
                            },
                            required: ['pattern']
                        }
                    }
                ],
                max_tokens: 1000
            }
        },
        {
            // ÈîôËØØÁöÑToolsÊ†ºÂºèÊ†∑Êú¨ÔºàÁ±ª‰ºº400ÈîôËØØÔºâ
            timestamp: new Date().toISOString(),
            requestId: 'mock-invalid-tools-001',
            provider: 'modelscope',
            model: 'Qwen/Qwen3-Coder-480B-A35B-Instruct',
            sampleType: 'invalid_tools_format',
            failureType: 'tools_format_validation',
            request: {
                model: 'Qwen/Qwen3-Coder-480B-A35B-Instruct',
                messages: [
                    {
                        role: 'user',
                        content: 'Search for files'
                    }
                ],
                tools: [
                    // ÈîôËØØÔºötoolsÊï∞ÁªÑ‰∏≠Ê∑∑Âêà‰∫Ü‰∏çÂêåÊ†ºÂºè
                    {
                        // Ê≠£Á°ÆÁöÑAnthropicÊ†ºÂºè
                        name: 'search_files',
                        description: 'Search for files',
                        input_schema: { type: 'object', properties: {} }
                    },
                    {
                        // ÈîôËØØÔºöÊ∑∑ÂêàÁöÑÊ†ºÂºè
                        type: 'function',
                        function: {
                            name: 'write_file',
                            description: 'Write file',
                            parameters: { type: 'object', properties: {} }
                        },
                        name: 'write_file' // ÈáçÂ§çÂ≠óÊÆµÂØºËá¥Ê†ºÂºèÈîôËØØ
                    },
                    // ÈîôËØØÔºö‰∏çÂÆåÊï¥ÁöÑÂØπË±° - Ëøô‰ºöÂØºËá¥"expected an json object"ÈîôËØØ
                    "invalid_tool_string", // Â≠óÁ¨¶‰∏≤ËÄå‰∏çÊòØÂØπË±°
                    {
                        // ÈîôËØØÔºöÁº∫Â∞ëÂøÖË¶ÅÂ≠óÊÆµ
                        description: 'Tool without name'
                    }
                ]
            }
        },
        {
            // ÈîôËØØÁöÑMessagesÊ†ºÂºèÊ†∑Êú¨
            timestamp: new Date().toISOString(),
            requestId: 'mock-invalid-messages-001',
            provider: 'shuaihong',
            model: 'gpt-4o-mini',
            sampleType: 'invalid_messages_format',
            failureType: 'messages_content_validation',
            request: {
                model: 'gpt-4o-mini',
                messages: [
                    {
                        role: 'user',
                        // ÈîôËØØÔºöcontentÂ∫îËØ•ÊòØstringÊàñarrayÔºå‰ΩÜËøôÈáåÊòØobject
                        content: {
                            type: 'text',
                            text: 'Hello'
                        }
                        // Ê≠£Á°ÆÂ∫îËØ•ÊòØÔºöcontent: [{ type: 'text', text: 'Hello' }] Êàñ content: 'Hello'
                    }
                ]
            }
        }
    ];
    
    return {
        samples: mockSamples,
        failurePatterns: {
            'tools_format_validation': 1,
            'messages_content_validation': 1
        },
        toolsFormatIssues: [
            {
                sampleIndex: 1,
                toolIndex: 1,
                issue: 'Mixed format in tools array',
                tool: mockSamples[1].request.tools[1]
            }
        ],
        messagesFormatIssues: [
            {
                sampleIndex: 2,
                messageIndex: 0,
                issue: 'Content is object instead of string or array',
                message: mockSamples[2].request.messages[0]
            }
        ]
    };
}

// üîß ÊûÑÂª∫MockÁ¨¨‰∏âÊñπÊúçÂä°Âô®ËøûÊé•È¢ÑÂ§ÑÁêÜÂô®
function buildMockPreprocessor(sampleAnalysis) {
    console.log('\nüîß Step 2: ÊûÑÂª∫MockÁ¨¨‰∏âÊñπÊúçÂä°Âô®ËøûÊé•È¢ÑÂ§ÑÁêÜÂô®');
    
    const preprocessorCode = `
/**
 * Mock Third-Party Server Connection Preprocessor
 * Âü∫‰∫éÁúüÂÆûÊï∞ÊçÆÂ∫ìÊ†∑Êú¨ÁöÑÊ†ºÂºèÈ™åËØÅÂíå‰øÆÂ§ç
 */

class MockConnectionPreprocessor {
    constructor(sampleAnalysis) {
        this.sampleAnalysis = sampleAnalysis;
        this.validationRules = this.buildValidationRules();
    }
    
    buildValidationRules() {
        return {
            // ToolsÊ†ºÂºèÈ™åËØÅËßÑÂàô
            tools: {
                // ÂøÖÈ°ªÊòØÊï∞ÁªÑ
                mustBeArray: true,
                // ÊØè‰∏™ÂÖÉÁ¥†ÂøÖÈ°ªÊòØÂØπË±°
                elementsValidator: (tool, index) => {
                    if (typeof tool !== 'object' || tool === null) {
                        return { valid: false, error: \`tools[\${index}] must be an object, got \${typeof tool}\` };
                    }
                    
                    // AnthropicÊ†ºÂºèÈ™åËØÅ
                    if (tool.name && tool.input_schema && !tool.function) {
                        if (!tool.name || typeof tool.name !== 'string') {
                            return { valid: false, error: \`tools[\${index}].name must be a non-empty string\` };
                        }
                        if (!tool.input_schema || typeof tool.input_schema !== 'object') {
                            return { valid: false, error: \`tools[\${index}].input_schema must be an object\` };
                        }
                        return { valid: true, format: 'anthropic' };
                    }
                    
                    // OpenAIÊ†ºÂºèÈ™åËØÅ
                    if (tool.type === 'function' && tool.function && !tool.name) {
                        if (!tool.function.name || typeof tool.function.name !== 'string') {
                            return { valid: false, error: \`tools[\${index}].function.name must be a non-empty string\` };
                        }
                        if (tool.function.parameters && typeof tool.function.parameters !== 'object') {
                            return { valid: false, error: \`tools[\${index}].function.parameters must be an object\` };
                        }
                        return { valid: true, format: 'openai' };
                    }
                    
                    return { valid: false, error: \`tools[\${index}] has invalid format - must be either Anthropic or OpenAI format\` };
                }
            },
            
            // MessagesÊ†ºÂºèÈ™åËØÅËßÑÂàô
            messages: {
                mustBeArray: true,
                elementsValidator: (message, index) => {
                    if (typeof message !== 'object' || message === null) {
                        return { valid: false, error: \`messages[\${index}] must be an object\` };
                    }
                    
                    if (!message.role || typeof message.role !== 'string') {
                        return { valid: false, error: \`messages[\${index}].role must be a non-empty string\` };
                    }
                    
                    // ContentÈ™åËØÅ
                    if (message.content !== undefined && message.content !== null) {
                        // ÂÖÅËÆ∏ÁöÑÊ†ºÂºèÔºöstring, array
                        if (typeof message.content === 'string') {
                            return { valid: true, contentType: 'string' };
                        } else if (Array.isArray(message.content)) {
                            return { valid: true, contentType: 'array' };
                        } else if (typeof message.content === 'object') {
                            return { valid: false, error: \`messages[\${index}].content cannot be a plain object - use string or array format\` };
                        }
                    }
                    
                    return { valid: true };
                }
            }
        };
    }
    
    // üîç È™åËØÅËØ∑Ê±ÇÊ†ºÂºè
    validateRequest(request) {
        const errors = [];
        const warnings = [];
        
        // È™åËØÅTools
        if (request.tools) {
            if (!Array.isArray(request.tools)) {
                errors.push('tools must be an array');
            } else {
                request.tools.forEach((tool, index) => {
                    const validation = this.validationRules.tools.elementsValidator(tool, index);
                    if (!validation.valid) {
                        errors.push(validation.error);
                    }
                });
            }
        }
        
        // È™åËØÅMessages
        if (request.messages) {
            if (!Array.isArray(request.messages)) {
                errors.push('messages must be an array');
            } else {
                request.messages.forEach((message, index) => {
                    const validation = this.validationRules.messages.elementsValidator(message, index);
                    if (!validation.valid) {
                        errors.push(validation.error);
                    }
                });
            }
        }
        
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }
    
    // üîß ‰øÆÂ§çËØ∑Ê±ÇÊ†ºÂºè
    fixRequestFormat(request) {
        const fixedRequest = JSON.parse(JSON.stringify(request));
        const appliedFixes = [];
        
        // ‰øÆÂ§çToolsÊ†ºÂºè
        if (fixedRequest.tools && Array.isArray(fixedRequest.tools)) {
            fixedRequest.tools = fixedRequest.tools.map((tool, index) => {
                if (typeof tool !== 'object' || tool === null) {
                    appliedFixes.push(\`Removed invalid tool at index \${index} (not an object)\`);
                    return null; // Ê†áËÆ∞‰∏∫Âà†Èô§
                }
                
                // Â§ÑÁêÜÊ∑∑ÂêàÊ†ºÂºèÈóÆÈ¢ò
                if (tool.name && tool.function) {
                    // ÊúânameÂèàÊúâfunctionÔºåËØ¥ÊòéÊòØÊ∑∑ÂêàÊ†ºÂºèÔºåÈúÄË¶ÅÈÄâÊã©‰∏ÄÁßç
                    if (tool.input_schema) {
                        // ‰ºòÂÖàÈÄâÊã©AnthropicÊ†ºÂºè
                        appliedFixes.push(\`Fixed mixed format tool at index \${index}, using Anthropic format\`);
                        return {
                            name: tool.name,
                            description: tool.description || tool.function.description || '',
                            input_schema: tool.input_schema || tool.function.parameters || {}
                        };
                    } else if (tool.function.parameters) {
                        // ËΩ¨Êç¢‰∏∫AnthropicÊ†ºÂºè
                        appliedFixes.push(\`Converted OpenAI format tool at index \${index} to Anthropic format\`);
                        return {
                            name: tool.function.name,
                            description: tool.function.description || '',
                            input_schema: tool.function.parameters
                        };
                    }
                }
                
                return tool;
            }).filter(tool => tool !== null); // ÁßªÈô§Êó†ÊïàÂ∑•ÂÖ∑
        }
        
        // ‰øÆÂ§çMessagesÊ†ºÂºè
        if (fixedRequest.messages && Array.isArray(fixedRequest.messages)) {
            fixedRequest.messages = fixedRequest.messages.map((message, index) => {
                if (message.content && typeof message.content === 'object' && !Array.isArray(message.content)) {
                    // Â∞ÜobjectÊ†ºÂºèÁöÑcontentËΩ¨Êç¢‰∏∫arrayÊ†ºÂºè
                    if (message.content.type === 'text' && message.content.text) {
                        appliedFixes.push(\`Fixed message[\${index}].content from object to array format\`);
                        return {
                            ...message,
                            content: [message.content]
                        };
                    } else {
                        // ËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤Ê†ºÂºè
                        appliedFixes.push(\`Fixed message[\${index}].content from object to string format\`);
                        return {
                            ...message,
                            content: JSON.stringify(message.content)
                        };
                    }
                }
                return message;
            });
        }
        
        return {
            request: fixedRequest,
            appliedFixes
        };
    }
    
    // üß™ Â§ÑÁêÜËØ∑Ê±ÇÔºàÈ™åËØÅ+‰øÆÂ§çÔºâ
    processRequest(request) {
        console.log('üîç [MOCK-PREPROCESSOR] Validating request format...');
        
        const validation = this.validateRequest(request);
        if (validation.valid) {
            console.log('‚úÖ [MOCK-PREPROCESSOR] Request format is valid');
            return { success: true, request, validation, appliedFixes: [] };
        }
        
        console.log(\`‚ö†Ô∏è [MOCK-PREPROCESSOR] Found \${validation.errors.length} format errors:\`);
        validation.errors.forEach(error => console.log(\`   - \${error}\`));
        
        console.log('üîß [MOCK-PREPROCESSOR] Attempting to fix format errors...');
        const { request: fixedRequest, appliedFixes } = this.fixRequestFormat(request);
        
        const postFixValidation = this.validateRequest(fixedRequest);
        
        return {
            success: postFixValidation.valid,
            request: fixedRequest,
            validation: postFixValidation,
            appliedFixes,
            originalErrors: validation.errors
        };
    }
}

// ÂØºÂá∫‰æõÂ§ñÈÉ®‰ΩøÁî®
module.exports = { MockConnectionPreprocessor };
`;

    const preprocessorPath = '/tmp/mock-connection-preprocessor.js';
    fs.writeFileSync(preprocessorPath, preprocessorCode);
    
    console.log(`‚úÖ MockÈ¢ÑÂ§ÑÁêÜÂô®Â∑≤ÂàõÂª∫: ${preprocessorPath}`);
    
    return preprocessorPath;
}

// üß™ Êï¥ÈìæË∑ØÂÆåÊï¥ÂìçÂ∫îÂ§öÂ∑•ÂÖ∑ÊµãËØï
async function runCompleteChainMultiToolTest(sampleAnalysis, preprocessorPath) {
    console.log('\nüß™ Step 3: Êï¥ÈìæË∑ØÂÆåÊï¥ÂìçÂ∫îÂ§öÂ∑•ÂÖ∑ÊµãËØï');
    
    // ÂØºÂÖ•MockÈ¢ÑÂ§ÑÁêÜÂô®
    const { MockConnectionPreprocessor } = require(preprocessorPath);
    const mockPreprocessor = new MockConnectionPreprocessor(sampleAnalysis);
    
    const testCases = [
        {
            name: 'Correct Anthropic Format',
            request: {
                model: 'claude-3-sonnet-20240229',
                messages: [
                    {
                        role: 'user',
                        content: [
                            {
                                type: 'text',
                                text: 'Search for TypeScript files and then create a summary file.'
                            }
                        ]
                    }
                ],
                tools: [
                    {
                        name: 'search_files',
                        description: 'Search for files in the project directory',
                        input_schema: {
                            type: 'object',
                            properties: {
                                pattern: { type: 'string', description: 'File pattern' }
                            },
                            required: ['pattern']
                        }
                    },
                    {
                        name: 'write_file',
                        description: 'Write content to a file',
                        input_schema: {
                            type: 'object',
                            properties: {
                                path: { type: 'string', description: 'File path' },
                                content: { type: 'string', description: 'File content' }
                            },
                            required: ['path', 'content']
                        }
                    }
                ],
                max_tokens: 1000
            },
            expectedSuccess: true
        },
        {
            name: 'Invalid Tools Format (Mixed)',
            request: {
                model: 'gpt-4o-mini',
                messages: [
                    {
                        role: 'user',
                        content: 'Test mixed tools format'
                    }
                ],
                tools: [
                    {
                        name: 'search_files',
                        description: 'Search files',
                        input_schema: { type: 'object', properties: {} }
                    },
                    {
                        // Ê∑∑ÂêàÊ†ºÂºè - ÊúânameÂèàÊúâfunction
                        name: 'duplicate_name',
                        type: 'function',
                        function: {
                            name: 'write_file',
                            description: 'Write file',
                            parameters: { type: 'object', properties: {} }
                        }
                    },
                    // Êó†ÊïàÂ∑•ÂÖ∑
                    "invalid_string_tool"
                ]
            },
            expectedSuccess: false // Â∫îËØ•Ë¢´‰øÆÂ§ç‰∏∫true
        },
        {
            name: 'Invalid Messages Format (Object Content)',
            request: {
                model: 'gpt-4o',
                messages: [
                    {
                        role: 'user',
                        // ÈîôËØØÔºöcontentÊòØobjectËÄå‰∏çÊòØstringÊàñarray
                        content: {
                            type: 'text',
                            text: 'Hello world'
                        }
                    }
                ]
            },
            expectedSuccess: false // Â∫îËØ•Ë¢´‰øÆÂ§ç‰∏∫true
        }
    ];
    
    const results = [];
    
    for (const testCase of testCases) {
        console.log(`\nüß™ Testing: ${testCase.name}`);
        console.log('üì§ Original request structure:', {
            hasTools: !!testCase.request.tools,
            toolsCount: testCase.request.tools?.length || 0,
            messagesCount: testCase.request.messages?.length || 0,
            contentType: testCase.request.messages?.[0]?.content ? 
                (Array.isArray(testCase.request.messages[0].content) ? 'array' : typeof testCase.request.messages[0].content) : 'none'
        });
        
        const result = mockPreprocessor.processRequest(testCase.request);
        
        console.log('üì• Processed result:', {
            success: result.success,
            validationErrors: result.validation.errors.length,
            appliedFixesCount: result.appliedFixes.length
        });
        
        if (result.appliedFixes.length > 0) {
            console.log('üîß Applied fixes:');
            result.appliedFixes.forEach(fix => console.log(`   - ${fix}`));
        }
        
        results.push({
            testCase: testCase.name,
            originalExpectedSuccess: testCase.expectedSuccess,
            actualSuccess: result.success,
            validationErrors: result.validation.errors,
            appliedFixes: result.appliedFixes,
            fixWorked: !testCase.expectedSuccess ? result.success : true
        });
    }
    
    return results;
}

// üìä ÁîüÊàêÊúÄÁªàÊä•Âëä
function generateFinalReport(sampleAnalysis, testResults, multiToolResults) {
    console.log('\nüìä Step 4: ÁîüÊàêÊúÄÁªàÊµãËØïÊä•Âëä');
    
    const report = {
        ...testResults,
        sampleAnalysis: {
            samplesCount: sampleAnalysis.samples?.length || 0,
            failurePatterns: sampleAnalysis.failurePatterns,
            toolsFormatIssues: sampleAnalysis.toolsFormatIssues?.length || 0,
            messagesFormatIssues: sampleAnalysis.messagesFormatIssues?.length || 0
        },
        multiToolTestResults: multiToolResults,
        summary: {
            totalTests: multiToolResults.length,
            successfulFixes: multiToolResults.filter(r => r.fixWorked).length,
            identifiedProblems: [
                'Tools array containing mixed format objects',
                'Tools array containing non-object elements (strings)',
                'Messages content as plain object instead of string/array',
                'Missing required fields in tool definitions',
                'System instructions being passed as user messages'
            ],
            recommendedSolutions: [
                'Implement strict tools format validation in preprocessing layer',
                'Add automatic format conversion for mixed tool definitions',
                'Validate messages content format before sending to providers',
                'Separate system instructions from user messages properly',
                'Add comprehensive format testing in CI pipeline'
            ]
        }
    };
    
    const reportPath = `test-critical-400-errors-fix-report-${Date.now()}.json`;
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    console.log('üìã ÊµãËØïÁªìÊûúÊ±áÊÄª:');
    console.log(`   Êï∞ÊçÆÂ∫ìÊ†∑Êú¨Êï∞Èáè: ${report.sampleAnalysis.samplesCount}`);
    console.log(`   ËØÜÂà´ÁöÑÊ†ºÂºèÈóÆÈ¢ò: ${report.sampleAnalysis.toolsFormatIssues + report.sampleAnalysis.messagesFormatIssues}`);
    console.log(`   Â§öÂ∑•ÂÖ∑ÊµãËØïÁî®‰æã: ${report.summary.totalTests}`);
    console.log(`   ÊàêÂäü‰øÆÂ§çÁöÑÈóÆÈ¢ò: ${report.summary.successfulFixes}`);
    
    console.log('\nüîç ÂèëÁé∞ÁöÑÂÖ≥ÈîÆÈóÆÈ¢ò:');
    report.summary.identifiedProblems.forEach(problem => {
        console.log(`   ‚ùå ${problem}`);
    });
    
    console.log('\nüí° Êé®ËçêËß£ÂÜ≥ÊñπÊ°à:');
    report.summary.recommendedSolutions.forEach(solution => {
        console.log(`   ‚úÖ ${solution}`);
    });
    
    console.log(`\nüìÅ ÂÆåÊï¥Êä•ÂëäÂ∑≤‰øùÂ≠ò: ${reportPath}`);
    
    // Âà§Êñ≠Êï¥‰ΩìÊàêÂäü
    const overallSuccess = report.summary.successfulFixes >= report.summary.totalTests * 0.8; // 80%ÊàêÂäüÁéá
    testResults.overallSuccess = overallSuccess;
    
    if (overallSuccess) {
        console.log('\nüéâ MockÊµãËØïÁ≥ªÁªüÈ™åËØÅÊàêÂäüÔºöËÉΩÂ§üËØÜÂà´Âπ∂‰øÆÂ§çCritical 400ÈîôËØØ');
        testResults.fixes.push('MockÈ¢ÑÂ§ÑÁêÜÂô®ËÉΩÂ§üÂ§ÑÁêÜtoolsÂíåmessagesÊ†ºÂºèÈóÆÈ¢ò');
        testResults.fixes.push('Ëá™Âä®Ê†ºÂºèËΩ¨Êç¢ÂíåÈ™åËØÅÊú∫Âà∂Â∑•‰ΩúÊ≠£Â∏∏');
        return true;
    } else {
        console.log('\n‚ùå MockÊµãËØïÁ≥ªÁªüÈúÄË¶ÅËøõ‰∏ÄÊ≠•ÊîπËøõÔºöÈÉ®ÂàÜÈóÆÈ¢òÊú™ËÉΩ‰øÆÂ§ç');
        testResults.problems.push('ÈÉ®ÂàÜÊ†ºÂºèÈóÆÈ¢òÁöÑ‰øÆÂ§çÊú∫Âà∂‰∏çÂÆåÂñÑ');
        return false;
    }
}

// ‰∏ªÊâßË°åÂáΩÊï∞
async function main() {
    try {
        console.log('üî¨ ÂºÄÂßãCritical 400ÈîôËØØ‰øÆÂ§çÁöÑÊï∞ÊçÆÂ∫ìÈ©±Âä®MockÊµãËØï');
        
        // Step 1: ÂàÜÊûêÊï∞ÊçÆÂ∫ìÊ†∑Êú¨
        const sampleAnalysis = analyzeDatabaseSamples();
        
        // Step 2: ÊûÑÂª∫MockÈ¢ÑÂ§ÑÁêÜÂô®
        const preprocessorPath = buildMockPreprocessor(sampleAnalysis);
        testResults.fixes.push('MockËøûÊé•È¢ÑÂ§ÑÁêÜÂô®ÊûÑÂª∫ÂÆåÊàê');
        
        // Step 3: Êï¥ÈìæË∑ØÂ§öÂ∑•ÂÖ∑ÊµãËØï
        const multiToolResults = await runCompleteChainMultiToolTest(sampleAnalysis, preprocessorPath);
        
        // Step 4: ÁîüÊàêÊä•Âëä
        const success = generateFinalReport(sampleAnalysis, testResults, multiToolResults);
        
        // Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
        try {
            fs.unlinkSync(preprocessorPath);
        } catch (e) {
            // ÂøΩÁï•Ê∏ÖÁêÜÈîôËØØ
        }
        
        process.exit(success ? 0 : 1);
        
    } catch (error) {
        console.error('\nüí• ÊµãËØïÊâßË°åÂ§±Ë¥•:', error.message);
        testResults.problems.push(`Execution error: ${error.message}`);
        process.exit(1);
    }
}

// ÊâßË°åÊµãËØï
if (require.main === module) {
    main();
}