/**
 * iFlow Server Compatibility Module
 * Handles iFlow API compatibility adjustments with enhanced tool calling and response processing
 */

import { ModuleInterface, ModuleMetrics } from '../../../interfaces/module/base-module';
import { EventEmitter } from 'events';
import { secureLogger } from '../../../utils/secure-logger';
import { API_DEFAULTS } from '../../../constants/api-defaults';
import { JQJsonHandler } from '../../../utils/jq-json-handler';
import { OpenAIStandardResponse, OpenAIErrorResponse } from './types/compatibility-types';
import { ERROR_MESSAGES } from '../../../constants/error-messages';

// ‚úÖ Configuration-driven constants - no more hardcoding
const IFLOW_CONSTANTS = {
  MILLISECONDS_PER_SECOND: 1000,  // Mathematical constant - acceptable
  MODULE_VERSION: '1.0.0'         // Module version - acceptable
};

interface ModuleProcessingContext {
  readonly requestId: string;
  readonly providerName?: string;
  readonly protocol?: string;
  readonly config?: {
    readonly endpoint?: string;
    readonly apiKey?: string;
    readonly timeout?: number;
    readonly maxRetries?: number;
    readonly actualModel?: string;
    readonly originalModel?: string;
  };
  metadata?: {
    protocolConfig?: {
      endpoint?: string;
      apiKey?: string;
      protocol?: string;
      timeout?: number;
      maxRetries?: number;
      customHeaders?: Record<string, string>;
    };
    [key: string]: any;
  };
}

export interface IFlowCompatibilityConfig {
  baseUrl: string;
  apiKey?: string;
  timeout: number;
  maxRetries: number;
  models: {
    available: string[];
    default: string;
    mapping?: Record<string, string>;
  };
  authentication: {
    method: 'Bearer' | 'APIKey' | 'Custom';
    format?: string;
  };
  parameters: {
    topK: {
      min: number;
      max: number;
      default: number;
    };
    temperature: {
      min: number;
      max: number;
      default: number;
    };
  };
  endpoints: {
    primary: string;
    fallback?: string[];
  };
}

export class IFlowCompatibilityModule extends EventEmitter implements ModuleInterface {
  private readonly id: string = 'iflow-compatibility';
  private readonly name: string = 'iFlow Compatibility Module';
  private readonly type: any = 'server-compatibility';
  private readonly version: string = IFLOW_CONSTANTS.MODULE_VERSION;
  private readonly config: IFlowCompatibilityConfig;
  private status: any = 'healthy';
  private isInitialized = false;
  private connections: Map<string, ModuleInterface> = new Map();
  private metrics = {
    requestsProcessed: 0,
    errorsHandled: 0,
    responsesFixed: 0,
    toolCallsProcessed: 0
  };

  constructor(config: IFlowCompatibilityConfig) {
    super();
    this.config = config;
    
    secureLogger.info('Initialize iFlow compatibility module', {
      endpoint: config.baseUrl,
      defaultModel: config.models.default,
      supportedModels: config.models.available.length
    });
  }

  getId(): string { 
    return this.id; 
  }

  getName(): string { 
    return this.name; 
  }

  getType(): any { 
    return this.type; 
  }

  getVersion(): string { 
    return this.version; 
  }

  getStatus(): any { 
    return this.status; 
  }

  getMetrics(): ModuleMetrics {
    return {
      requestsProcessed: this.metrics.requestsProcessed,
      averageProcessingTime: 0,
      errorRate: this.metrics.errorsHandled / Math.max(this.metrics.requestsProcessed, 1),
      memoryUsage: 0,
      cpuUsage: 0
    };
  }

  async configure(config: any): Promise<void> {
    secureLogger.info('iFlow compatibility module config updated');
  }

  async reset(): Promise<void> {
    this.status = 'healthy';
    this.emit('statusChanged', { health: this.status });
  }

  async healthCheck(): Promise<{ healthy: boolean; details: any }> {
    return {
      healthy: this.status === 'healthy',
      details: {
        status: this.status,
        initialized: this.isInitialized,
        endpoint: this.config.baseUrl,
        defaultModel: this.config.models.default
      }
    };
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      this.status = 'healthy';
      this.isInitialized = true;
      this.emit('statusChanged', { health: this.status });
      secureLogger.info('iFlow compatibility module initialized');
    } catch (error) {
      this.status = 'unhealthy';
      this.emit('statusChanged', { health: this.status });
      secureLogger.error('iFlow compatibility module init failed:', { error: error.message });
      throw error;
    }
  }

  async start(): Promise<void> {
    if (!this.isInitialized) {
      await this.initialize();
    }
  }

  async stop(): Promise<void> {
    this.status = 'stopped';
    this.emit('statusChanged', { health: this.status });
  }

  async cleanup(): Promise<void> {
    await this.stop();
    this.removeAllListeners();
  }

  async processRequest(request: any, routingDecision: any, context: ModuleProcessingContext): Promise<any> {
    try {
      this.metrics.requestsProcessed++;
      const processedRequest = { ...request };

      // ‚úÖ Configuration-driven model selection
      if (context?.config?.actualModel) {
        processedRequest.model = context.config.actualModel;
      } else if (!processedRequest.model) {
        processedRequest.model = this.config.models.default;
      }
      
      // Apply model mapping if configured
      if (this.config.models.mapping && this.config.models.mapping[processedRequest.model]) {
        const mappedModel = this.config.models.mapping[processedRequest.model];
        secureLogger.debug('üîÑ iFlowÊ®°ÂûãÊò†Â∞Ñ', {
          originalModel: processedRequest.model,
          mappedModel: mappedModel,
          requestId: context.requestId
        });
        processedRequest.model = mappedModel;
      }

      // üîß Â∑•ÂÖ∑Ê†ºÂºèÂ§ÑÁêÜ - Á°Æ‰øùÂ∑•ÂÖ∑Ë∞ÉÁî®Ê†ºÂºèÂÖºÂÆπ
      if (processedRequest.tools && Array.isArray(processedRequest.tools)) {
        processedRequest.tools = this.normalizeToolCalls(processedRequest.tools, context.requestId);
        this.metrics.toolCallsProcessed += processedRequest.tools.length;
      }

      // ‚úÖ Configuration-driven parameter processing
      if (!processedRequest.top_k && processedRequest.temperature) {
        const topKConfig = this.config.parameters.topK;
        processedRequest.top_k = Math.max(
          topKConfig.min,
          Math.min(topKConfig.max, Math.floor(processedRequest.temperature * topKConfig.max))
        );
        
        secureLogger.debug('üîß iFlowÂä®ÊÄÅtop_kËÆ°ÁÆó', {
          temperature: processedRequest.temperature,
          calculatedTopK: processedRequest.top_k,
          topKRange: `${topKConfig.min}-${topKConfig.max}`,
          requestId: context.requestId
        });
      }
      
      // Apply temperature limits if configured
      if (processedRequest.temperature !== undefined) {
        const tempConfig = this.config.parameters.temperature;
        if (processedRequest.temperature < tempConfig.min) {
          processedRequest.temperature = tempConfig.min;
        } else if (processedRequest.temperature > tempConfig.max) {
          processedRequest.temperature = tempConfig.max;
        }
      }

      // Á°Æ‰øùËØ∑Ê±ÇÁ¨¶ÂêàOpenAIÊ†áÂáÜÊ†ºÂºè
      this.validateRequestFormat(processedRequest, context.requestId);

      if (context.metadata) {
        if (!context.metadata.protocolConfig) {
          context.metadata.protocolConfig = {};
        }
        
        context.metadata.protocolConfig.endpoint = this.config.baseUrl;
        context.metadata.protocolConfig.protocol = 'openai';
        context.metadata.protocolConfig.timeout = this.config.timeout;
        context.metadata.protocolConfig.maxRetries = this.config.maxRetries;
        
        // ‚úÖ Configuration-driven authentication
        if (this.config.apiKey) {
          context.metadata.protocolConfig.apiKey = this.config.apiKey;
          
          // Use configured authentication method and format
          const authMethod = this.config.authentication.method;
          const authFormat = this.config.authentication.format || `${authMethod} {token}`;
          const authHeader = authFormat.replace('{token}', this.config.apiKey);
          
          context.metadata.protocolConfig.customHeaders = {
            'Authorization': authHeader,
            'Content-Type': API_DEFAULTS.CONTENT_TYPES.JSON
          };
          
          secureLogger.debug('üîê iFlowËÆ§ËØÅÈÖçÁΩÆ', {
            authMethod: authMethod,
            authFormat: authFormat,
            hasApiKey: !!this.config.apiKey,
            requestId: context.requestId
          });
        }
      }

      return processedRequest;

    } catch (error) {
      this.metrics.errorsHandled++;
      secureLogger.error('iFlow compatibility processing failed', {
        requestId: context.requestId,
        error: error.message,
        stack: error.stack
      });
      return request;
    }
  }

  /**
   * Ê†áÂáÜÂåñÂ∑•ÂÖ∑Ë∞ÉÁî®Ê†ºÂºè‰∏∫OpenAIÊ†áÂáÜÊ†ºÂºè
   */
  private normalizeToolCalls(tools: any[], requestId: string): any[] {
    try {
      return tools.map((tool, index) => {
        // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊòØOpenAIÊ†ºÂºè
        if (tool.type === 'function' && tool.function) {
          // Á°Æ‰øùfunctionÂ≠óÊÆµÁªìÊûÑÊ≠£Á°Æ
          const normalizedTool = { ...tool };
          
          // Á°Æ‰øùargumentsÊòØÂ≠óÁ¨¶‰∏≤Ê†ºÂºè
          if (normalizedTool.function.arguments && typeof normalizedTool.function.arguments !== 'string') {
            try {
              normalizedTool.function.arguments = JQJsonHandler.stringifyJson(normalizedTool.function.arguments);
            } catch (e) {
              normalizedTool.function.arguments = '{}';
              secureLogger.warn('‚ö†Ô∏è iFlowÂ∑•ÂÖ∑ÂèÇÊï∞Â∫èÂàóÂåñÂ§±Ë¥•Ôºå‰ΩøÁî®Á©∫ÂØπË±°', {
                requestId,
                toolIndex: index,
                toolName: normalizedTool.function.name,
                error: e.message
              });
            }
          }
          
          return normalizedTool;
        }
        
        // Â¶ÇÊûúÊòØAnthropicÊ†ºÂºèÔºåËΩ¨Êç¢‰∏∫OpenAIÊ†ºÂºè
        if (tool.name && tool.description && tool.input_schema) {
          secureLogger.debug('üîÑ iFlowÂ∑•ÂÖ∑Ê†ºÂºèËΩ¨Êç¢ Anthropic ‚Üí OpenAI', {
            requestId,
            toolIndex: index,
            toolName: tool.name
          });
          
          return {
            type: 'function',
            function: {
              name: tool.name,
              description: tool.description || '',
              parameters: {
                type: tool.input_schema.type || 'object',
                properties: tool.input_schema.properties || {},
                required: tool.input_schema.required || []
              }
            }
          };
        }
        
        // ÂÖ∂‰ªñÊÉÖÂÜµÔºåÂ∞ùËØïÊ†áÂáÜÂåñ
        return {
          type: 'function',
          function: {
            name: tool.name || tool.function?.name || `tool_${index}`,
            description: tool.description || tool.function?.description || '',
            parameters: tool.parameters || tool.input_schema || tool.function?.parameters || {}
          }
        };
      });
    } catch (error) {
      secureLogger.error('‚ùå iFlowÂ∑•ÂÖ∑Ê†ºÂºèÊ†áÂáÜÂåñÂ§±Ë¥•', {
        requestId,
        error: error.message
      });
      return tools;
    }
  }

  /**
   * È™åËØÅËØ∑Ê±ÇÊ†ºÂºèÊòØÂê¶Á¨¶ÂêàOpenAIÊ†áÂáÜ
   */
  private validateRequestFormat(request: any, requestId: string): void {
    try {
      const issues: string[] = [];
      
      // Ê£ÄÊü•ÂøÖÈúÄÂ≠óÊÆµ
      if (!request.model) {
        issues.push('missing_model');
      }
      
      if (!request.messages || !Array.isArray(request.messages)) {
        issues.push('missing_or_invalid_messages');
      }
      
      // Ê£ÄÊü•Â∑•ÂÖ∑Ê†ºÂºè
      if (request.tools && Array.isArray(request.tools)) {
        for (let i = 0; i < request.tools.length; i++) {
          const tool = request.tools[i];
          if (tool.type !== 'function' || !tool.function) {
            issues.push(`invalid_tool_format_at_index_${i}`);
          } else if (!tool.function.name) {
            issues.push(`missing_tool_name_at_index_${i}`);
          }
        }
      }
      
      if (issues.length > 0) {
        secureLogger.warn('‚ö†Ô∏è iFlowËØ∑Ê±ÇÊ†ºÂºèÈ™åËØÅÂèëÁé∞ÈóÆÈ¢ò', {
          requestId,
          issues,
          model: request.model,
          messageCount: request.messages?.length
        });
      } else {
        secureLogger.debug('‚úÖ iFlowËØ∑Ê±ÇÊ†ºÂºèÈ™åËØÅÈÄöËøá', {
          requestId,
          model: request.model,
          messageCount: request.messages?.length,
          toolCount: request.tools?.length || 0
        });
      }
    } catch (error) {
      secureLogger.error('‚ùå iFlowËØ∑Ê±ÇÊ†ºÂºèÈ™åËØÅÂ§±Ë¥•', {
        requestId,
        error: error.message
      });
    }
  }

  async processResponse(response: any, routingDecision: any, context: ModuleProcessingContext): Promise<any> {
    try {
      if (!response || typeof response !== 'object') {
        this.metrics.errorsHandled++;
        return response;
      }

      // È™åËØÅÂíå‰øÆÂ§çÂìçÂ∫îÊ†ºÂºè
      const validatedResponse = this.validateAndFixResponse(response, context.requestId);
      if (validatedResponse) {
        this.metrics.responsesFixed++;
        return validatedResponse;
      }

      const processedResponse = { ...response };

      // üîß Á°Æ‰øùÂìçÂ∫îÂåÖÂê´ÂøÖË¶ÅÁöÑOpenAIÂÖºÂÆπÂ≠óÊÆµ
      if (!processedResponse.id) {
        const timestamp = Date.now();
        const randomSuffix = Math.random().toString(36).substr(2, 9);
        processedResponse.id = 'chatcmpl-iflow-' + timestamp + '-' + randomSuffix;
      }

      if (!processedResponse.object) {
        processedResponse.object = 'chat.completion';
      }

      if (!processedResponse.created) {
        processedResponse.created = Math.floor(Date.now() / IFLOW_CONSTANTS.MILLISECONDS_PER_SECOND);
      }

      // üîß Ê†áÂáÜÂåñchoicesÊï∞ÁªÑ
      if (processedResponse.choices && Array.isArray(processedResponse.choices)) {
        processedResponse.choices = this.normalizeChoices(processedResponse.choices, context.requestId);
      }

      // üîß Ê†áÂáÜÂåñÂ∑•ÂÖ∑Ë∞ÉÁî®ÂìçÂ∫î
      if (processedResponse.choices) {
        for (let i = 0; i < processedResponse.choices.length; i++) {
          const choice = processedResponse.choices[i];
          if (choice.message && choice.message.tool_calls) {
            choice.message.tool_calls = this.normalizeToolCallResponses(choice.message.tool_calls, context.requestId);
          }
        }
      }

      // üîß Ê†áÂáÜÂåñusage‰ø°ÊÅØ
      if (processedResponse.usage) {
        processedResponse.usage = this.normalizeUsage(processedResponse.usage, context.requestId);
      }

      // üîß Â§ÑÁêÜiFlowÁâπÂÆöÂ≠óÊÆµ
      if (processedResponse.reasoning_content) {
        processedResponse.iflow_reasoning = processedResponse.reasoning_content;
      }

      // üîß ÂìçÂ∫îÈ™åËØÅ
      this.validateResponseFormat(processedResponse, context.requestId);

      return processedResponse;

    } catch (error) {
      this.metrics.errorsHandled++;
      secureLogger.error('iFlow response processing failed', {
        requestId: context.requestId,
        error: error.message,
        stack: error.stack
      });
      return response;
    }
  }

  /**
   * È™åËØÅÂíå‰øÆÂ§çÂìçÂ∫îÊ†ºÂºè
   */
  private validateAndFixResponse(response: any, requestId: string): any | null {
    try {
      // Â¶ÇÊûúÂ∑≤ÁªèÊòØÊ†áÂáÜOpenAIÊ†ºÂºèÔºåÁõ¥Êé•ËøîÂõû
      if (this.isValidOpenAIResponse(response)) {
        secureLogger.debug('‚úÖ iFlowÂìçÂ∫îÂ∑≤Á¨¶ÂêàOpenAIÊ†áÂáÜÊ†ºÂºè', {
          requestId,
          responseId: response.id,
          choiceCount: response.choices?.length
        });
        return null;
      }

      // Â∞ùËØï‰øÆÂ§çÂ∏∏ËßÅÁöÑÂìçÂ∫îÊ†ºÂºèÈóÆÈ¢ò
      const fixedResponse: OpenAIStandardResponse = {
        id: response.id || `chatcmpl-iflow-${Date.now()}${Math.random().toString(36).substr(2, 9)}`,
        object: 'chat.completion',
        created: response.created || Math.floor(Date.now() / 1000),
        model: response.model || 'iflow-model',
        choices: this.fixChoicesArray(response.choices || []),
        usage: this.fixUsageStatistics(response.usage)
      };

      secureLogger.debug('üîß iFlowÂìçÂ∫îÊ†ºÂºè‰øÆÂ§çÂÆåÊàê', {
        requestId,
        originalHasId: !!response.id,
        originalHasChoices: Array.isArray(response.choices),
        fixedChoiceCount: fixedResponse.choices.length
      });

      return fixedResponse;
    } catch (error) {
      secureLogger.error('‚ùå iFlowÂìçÂ∫îÊ†ºÂºè‰øÆÂ§çÂ§±Ë¥•', {
        requestId,
        error: error.message
      });
      return null;
    }
  }

  /**
   * Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊúâÊïàÁöÑOpenAIÂìçÂ∫îÊ†ºÂºè
   */
  private isValidOpenAIResponse(response: any): boolean {
    return !!(
      response &&
      response.id &&
      response.object === 'chat.completion' &&
      Array.isArray(response.choices) &&
      response.usage &&
      typeof response.usage.total_tokens === 'number'
    );
  }

  /**
   * ‰øÆÂ§çchoicesÊï∞ÁªÑ
   */
  private fixChoicesArray(choices: any[]): OpenAIStandardResponse['choices'] {
    if (!Array.isArray(choices) || choices.length === 0) {
      return [
        {
          index: 0,
          message: { role: 'assistant', content: '' },
          finish_reason: 'stop',
        },
      ];
    }

    return choices.map((choice, index) => ({
      index: choice.index ?? index,
      message: {
        role: 'assistant',
        content: choice.message?.content || '',
        tool_calls: choice.message?.tool_calls ? this.fixToolCallsFormat(choice.message.tool_calls) : undefined,
      },
      finish_reason: choice.finish_reason || 'stop',
    }));
  }

  /**
   * ‰øÆÂ§çÂ∑•ÂÖ∑Ë∞ÉÁî®Ê†ºÂºè
   */
  private fixToolCallsFormat(toolCalls: any[]): any[] {
    return toolCalls.map(toolCall => ({
      id: toolCall.id || `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'function',
      function: {
        name: toolCall.function?.name || '',
        arguments:
          typeof toolCall.function?.arguments === 'string'
            ? toolCall.function.arguments
            : JQJsonHandler.stringifyJson(toolCall.function?.arguments || {}),
      },
    }));
  }

  /**
   * ‰øÆÂ§çusageÁªüËÆ°‰ø°ÊÅØ
   */
  private fixUsageStatistics(usage: any): { prompt_tokens: number; completion_tokens: number; total_tokens: number } {
    const fixedUsage = {
      prompt_tokens: usage?.prompt_tokens || 0,
      completion_tokens: usage?.completion_tokens || 0,
      total_tokens: usage?.total_tokens || 0,
    };

    // Ëá™Âä®ËÆ°ÁÆótotal_tokensÂ¶ÇÊûúÁº∫Â§±
    if (fixedUsage.total_tokens === 0) {
      fixedUsage.total_tokens = fixedUsage.prompt_tokens + fixedUsage.completion_tokens;
    }

    return fixedUsage;
  }

  /**
   * Ê†áÂáÜÂåñchoicesÊï∞ÁªÑ
   */
  private normalizeChoices(choices: any[], requestId: string): any[] {
    try {
      return choices.map((choice, index) => {
        const normalizedChoice = { ...choice };

        // Á°Æ‰øùindexÂ≠óÊÆµÂ≠òÂú®
        if (normalizedChoice.index === undefined) {
          normalizedChoice.index = index;
        }

        // Á°Æ‰øùfinish_reasonÂ≠òÂú®
        if (!normalizedChoice.finish_reason) {
          if (normalizedChoice.message?.tool_calls) {
            normalizedChoice.finish_reason = 'tool_calls';
          } else if (normalizedChoice.message?.content) {
            normalizedChoice.finish_reason = 'stop';
          } else {
            normalizedChoice.finish_reason = 'stop';
          }
        }

        // Á°Æ‰øùmessageÁªìÊûÑÂÆåÊï¥
        if (normalizedChoice.message && typeof normalizedChoice.message === 'object') {
          if (!normalizedChoice.message.role) {
            normalizedChoice.message.role = 'assistant';
          }
          
          // Á°Æ‰øùcontentÂ≠óÊÆµÂ≠òÂú®
          if (normalizedChoice.message.content === undefined) {
            normalizedChoice.message.content = normalizedChoice.message.tool_calls ? '' : 'Response generated successfully.';
          }

          // Ê†áÂáÜÂåñÂ∑•ÂÖ∑Ë∞ÉÁî®
          if (normalizedChoice.message.tool_calls) {
            normalizedChoice.message.tool_calls = this.normalizeToolCallResponses(normalizedChoice.message.tool_calls, requestId);
          }
        }

        return normalizedChoice;
      });
    } catch (error) {
      secureLogger.error('‚ùå iFlow choicesÊ†áÂáÜÂåñÂ§±Ë¥•', {
        requestId,
        error: error.message
      });
      return choices;
    }
  }

  /**
   * Ê†áÂáÜÂåñÂ∑•ÂÖ∑Ë∞ÉÁî®ÂìçÂ∫î
   */
  private normalizeToolCallResponses(toolCalls: any[], requestId: string): any[] {
    try {
      return toolCalls.map((toolCall) => {
        const normalizedToolCall = { ...toolCall };

        // Á°Æ‰øùÂøÖÈúÄÂ≠óÊÆµÂ≠òÂú®
        if (!normalizedToolCall.id) {
          normalizedToolCall.id = `call_iflow_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        if (!normalizedToolCall.type) {
          normalizedToolCall.type = 'function';
        }

        // Á°Æ‰øùfunctionÂ≠óÊÆµÁªìÊûÑÊ≠£Á°Æ
        if (normalizedToolCall.function) {
          if (typeof normalizedToolCall.function.arguments !== 'string') {
            try {
              normalizedToolCall.function.arguments = JQJsonHandler.stringifyJson(normalizedToolCall.function.arguments || {});
            } catch (e) {
              normalizedToolCall.function.arguments = '{}';
              secureLogger.warn('‚ö†Ô∏è iFlowÂ∑•ÂÖ∑ÂìçÂ∫îÂèÇÊï∞Â∫èÂàóÂåñÂ§±Ë¥•Ôºå‰ΩøÁî®Á©∫ÂØπË±°', {
                requestId,
                toolCallId: normalizedToolCall.id,
                toolName: normalizedToolCall.function.name,
                error: e.message
              });
            }
          }

          if (!normalizedToolCall.function.name) {
            normalizedToolCall.function.name = 'unknown_function';
          }
        } else {
          normalizedToolCall.function = {
            name: 'unknown_function',
            arguments: '{}'
          };
        }

        return normalizedToolCall;
      });
    } catch (error) {
      secureLogger.error('‚ùå iFlowÂ∑•ÂÖ∑Ë∞ÉÁî®ÂìçÂ∫îÊ†áÂáÜÂåñÂ§±Ë¥•', {
        requestId,
        error: error.message
      });
      return toolCalls;
    }
  }

  /**
   * Ê†áÂáÜÂåñusage‰ø°ÊÅØ
   */
  private normalizeUsage(usage: any, requestId: string): any {
    try {
      const normalizedUsage = { ...usage };

      // Á°Æ‰øùÂü∫Á°ÄÂ≠óÊÆµÂ≠òÂú®
      if (normalizedUsage.prompt_tokens === undefined) {
        normalizedUsage.prompt_tokens = 0;
      }

      if (normalizedUsage.completion_tokens === undefined) {
        normalizedUsage.completion_tokens = 0;
      }

      if (normalizedUsage.total_tokens === undefined) {
        normalizedUsage.total_tokens = normalizedUsage.prompt_tokens + normalizedUsage.completion_tokens;
      }

      return normalizedUsage;
    } catch (error) {
      secureLogger.error('‚ùå iFlow usageÊ†áÂáÜÂåñÂ§±Ë¥•', {
        requestId,
        error: error.message
      });
      return usage;
    }
  }

  /**
   * È™åËØÅÂìçÂ∫îÊ†ºÂºè
   */
  private validateResponseFormat(response: any, requestId: string): void {
    try {
      const issues: string[] = [];
      
      // Ê£ÄÊü•ÂøÖÈúÄÂ≠óÊÆµ
      if (!response.id) {
        issues.push('missing_id');
      }
      
      if (response.object !== 'chat.completion') {
        issues.push('invalid_object');
      }
      
      if (!Array.isArray(response.choices)) {
        issues.push('missing_or_invalid_choices');
      } else {
        // Ê£ÄÊü•choicesÁªìÊûÑ
        for (let i = 0; i < response.choices.length; i++) {
          const choice = response.choices[i];
          if (typeof choice.index !== 'number') {
            issues.push(`invalid_choice_index_at_${i}`);
          }
          if (!choice.message || typeof choice.message !== 'object') {
            issues.push(`missing_or_invalid_message_at_${i}`);
          } else {
            if (!choice.message.role) {
              issues.push(`missing_message_role_at_${i}`);
            }
          }
          if (!choice.finish_reason) {
            issues.push(`missing_finish_reason_at_${i}`);
          }
        }
      }
      
      if (!response.usage || typeof response.usage !== 'object') {
        issues.push('missing_or_invalid_usage');
      } else {
        if (typeof response.usage.total_tokens !== 'number') {
          issues.push('missing_or_invalid_total_tokens');
        }
      }
      
      if (issues.length > 0) {
        secureLogger.warn('‚ö†Ô∏è iFlowÂìçÂ∫îÊ†ºÂºèÈ™åËØÅÂèëÁé∞ÈóÆÈ¢ò', {
          requestId,
          issues,
          responseId: response.id,
          choiceCount: response.choices?.length
        });
      } else {
        secureLogger.debug('‚úÖ iFlowÂìçÂ∫îÊ†ºÂºèÈ™åËØÅÈÄöËøá', {
          requestId,
          responseId: response.id,
          choiceCount: response.choices?.length,
          hasUsage: !!response.usage
        });
      }
    } catch (error) {
      secureLogger.error('‚ùå iFlowÂìçÂ∫îÊ†ºÂºèÈ™åËØÅÂ§±Ë¥•', {
        requestId,
        error: error.message
      });
    }
  }

  async process(request: any): Promise<any> {
    const context: ModuleProcessingContext = {
      requestId: Date.now().toString(),
      providerName: 'iflow',
      protocol: 'openai'
    };
    
    return this.processRequest(request, null, context);
  }

  /**
   * Áªü‰∏ÄÈîôËØØÂ§ÑÁêÜÊñπÊ≥ïÂç†‰ΩçÁ¨¶
   */
  async handleError(error: any, context: ModuleProcessingContext): Promise<OpenAIErrorResponse> {
    // Âç†‰ΩçÁ¨¶ÂÆûÁé∞
    return {
      error: {
        message: 'Not implemented',
        type: 'api_error',
        code: 'not_implemented',
        param: null,
      },
    };
  }

  // ModuleInterfaceËøûÊé•ÁÆ°ÁêÜÊñπÊ≥ï
  addConnection(module: ModuleInterface): void {
    this.connections.set(module.getId(), module);
  }

  removeConnection(moduleId: string): void {
    this.connections.delete(moduleId);
  }

  getConnection(moduleId: string): ModuleInterface | undefined {
    return this.connections.get(moduleId);
  }

  getConnections(): ModuleInterface[] {
    return Array.from(this.connections.values());
  }

  hasConnection(moduleId: string): boolean {
    return this.connections.has(moduleId);
  }

  clearConnections(): void {
    this.connections.clear();
  }

  getConnectionCount(): number {
    return this.connections.size;
  }

  // Ê®°ÂùóÈó¥ÈÄö‰ø°ÊñπÊ≥ï
  async sendToModule(targetModuleId: string, message: any, type?: string): Promise<any> {
    const targetModule = this.connections.get(targetModuleId);
    if (targetModule) {
      // ÂèëÈÄÅÊ∂àÊÅØÂà∞ÁõÆÊ†áÊ®°Âùó
      targetModule.onModuleMessage((sourceModuleId: string, msg: any, msgType: string) => {
        this.emit('moduleMessage', { fromModuleId: sourceModuleId, message: msg, type: msgType, timestamp: new Date() });
      });
      return Promise.resolve({ success: true, targetModuleId, message, type });
    }
    return Promise.resolve({ success: false, targetModuleId, message, type });
  }

  async broadcastToModules(message: any, type?: string): Promise<void> {
    const promises: Promise<any>[] = [];
    this.connections.forEach(module => {
      promises.push(this.sendToModule(module.getId(), message, type));
    });
    await Promise.allSettled(promises);
  }

  onModuleMessage(listener: (sourceModuleId: string, message: any, type: string) => void): void {
    this.on('moduleMessage', (data: any) => {
      listener(data.fromModuleId, data.message, data.type);
    });
  }
}