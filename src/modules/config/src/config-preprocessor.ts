import * as fs from 'fs';
import * as path from 'path';
import { 
  RoutingTable, 
  ProviderInfo, 
  RouteMapping, 
  ServerInfo,
  ConfigPreprocessResult,
  ModelInfo
} from './routing-table-types';
import { JQJsonHandler } from '../../error-handler/src/utils/jq-json-handler';
import { RCCError, RCCErrorCode } from '../../types/src';
import { EnhancedErrorHandler } from '../../error-handler/src/enhanced-error-handler';
import { ModuleDebugIntegration } from '../../logging/src/debug-integration';

// Export the result type for external use
export { ConfigPreprocessResult } from './routing-table-types';

export class ConfigPreprocessor {
  private static systemConfig: any = null;
  
  private static errorHandler: EnhancedErrorHandler = new EnhancedErrorHandler();
  private static debugIntegration: ModuleDebugIntegration = new ModuleDebugIntegration({
    moduleId: 'config',
    moduleName: 'ConfigPreprocessor',
    enabled: true,
    captureLevel: 'full'
  });
  
  public static async preprocess(configPath: string): Promise<ConfigPreprocessResult> {
    const startTime = Date.now();
    const timestamp = new Date().toISOString();
    const requestId = `config-${Date.now()}`;
    
    // 初始化debug系统并开始会话
    await ConfigPreprocessor.debugIntegration.initialize();
    const sessionId = ConfigPreprocessor.debugIntegration.startSession();
    
    // 记录输入
    ConfigPreprocessor.debugIntegration.recordInput(requestId, { configPath });
    
    try {
      // 验证配置文件路径
      if (!configPath) {
        throw new RCCError('Config path is required', RCCErrorCode.CONFIG_INVALID, 'config');
      }
      
      if (!fs.existsSync(configPath)) {
        throw new RCCError(`Config file not found: ${configPath}`, RCCErrorCode.CONFIG_MISSING, 'config');
      }
      
      const rawConfig = ConfigPreprocessor._readConfigFile(configPath);
      const parsedConfig = ConfigPreprocessor._parseConfigContent(rawConfig);
      const systemConfig = ConfigPreprocessor._loadSystemConfig();
      const providers = ConfigPreprocessor._expandProviders(parsedConfig.providers || [], systemConfig);
      const routes = ConfigPreprocessor._generateRoutes(parsedConfig.router || {}, providers);
      
      const routingTable: RoutingTable = {
        providers,
        routes,
        server: ConfigPreprocessor._normalizeServerConfig(parsedConfig.server || {}),
        apiKey: parsedConfig.APIKEY || parsedConfig.apiKey || 'default-key',
        version: parsedConfig.version || '4.1',
        description: parsedConfig.description || 'Generated by ConfigPreprocessor',
        lastUpdated: timestamp
      };
      
      const result = {
        success: true,
        routingTable,
        metadata: {
          configPath,
          processingTime: Date.now() - startTime,
          timestamp,
          sourceFormat: 'v4' as const
        }
      };
      
      // 记录输出
      ConfigPreprocessor.debugIntegration.recordOutput(requestId, result);
      
      // 结束debug会话
      await ConfigPreprocessor.debugIntegration.endSession();
      
      return result;
      
    } catch (error: unknown) {
      // 记录错误到debug系统
      ConfigPreprocessor.debugIntegration.recordError(requestId, error as Error);
      
      // 结束debug会话
      await ConfigPreprocessor.debugIntegration.endSession();
      
      const processingError = error as Error;
      return {
        success: false,
        error: {
          code: RCCErrorCode.CONFIG_PARSE_ERROR,
          message: processingError.message,
          details: { configPath }
        },
        metadata: {
          configPath,
          processingTime: Date.now() - startTime,
          timestamp,
          sourceFormat: 'unknown' as const
        }
      };
    }
  }
  
  private static _readConfigFile(configPath: string): any {
    const fileContent = fs.readFileSync(configPath, 'utf8');
    return JQJsonHandler.parseJsonString(fileContent);
  }
  
  private static _loadSystemConfig(): any {
    if (this.systemConfig) {
      return this.systemConfig;
    }
    
    const possiblePaths = [
      path.join(process.cwd(), 'config', 'system-config.json'),
      path.join(__dirname, '..', '..', '..', 'config', 'system-config.json'),
      path.join(__dirname, '..', '..', '..', '..', 'config', 'system-config.json')
    ];

    for (const configPath of possiblePaths) {
      if (fs.existsSync(configPath)) {
        try {
          const systemConfigContent = fs.readFileSync(configPath, 'utf8');
          this.systemConfig = JQJsonHandler.parseJsonString(systemConfigContent);
          return this.systemConfig;
        } catch (err) {
          continue;
        }
      }
    }
    
    return {}; // 返回空对象而不是抛出错误
  }
  
  private static _parseConfigContent(config: any): any {
    return {
      providers: config.Providers || config.providers || [],
      router: config.router || {},
      server: config.server || {},
      APIKEY: config.APIKEY || config.apiKey,
      version: config.version,
      description: config.description
    };
  }
  
  private static _expandProviders(providers: any[], systemConfig: any): ProviderInfo[] {
    return providers.map(provider => {
      const providerName = provider.name.toLowerCase();
      const systemProviderConfig = systemConfig.providerTypes?.[providerName];

      // 处理serverCompatibility配置
      let serverCompatibility = provider.serverCompatibility;
      
      // 如果没有提供serverCompatibility配置，尝试从系统配置获取
      if (!serverCompatibility && systemProviderConfig?.serverCompatibility) {
        serverCompatibility = {
          use: systemProviderConfig.serverCompatibility,
          options: {}
        };
      } else if (!serverCompatibility) {
        serverCompatibility = {
          use: provider.name,
          options: {}
        };
      }
      
      // 确保options对象存在
      if (!serverCompatibility.options) {
        serverCompatibility.options = {};
      }
      
      // 如果有系统配置，增强serverCompatibility选项
      if (systemProviderConfig) {
        if (systemProviderConfig.timeout) {
          serverCompatibility.options.timeout = systemProviderConfig.timeout;
        }
        if (systemProviderConfig.maxRetries) {
          serverCompatibility.options.maxRetries = systemProviderConfig.maxRetries;
        }
        if (systemProviderConfig.protocol) {
          serverCompatibility.options.protocol = systemProviderConfig.protocol;
        }
        if (systemProviderConfig.transformer) {
          serverCompatibility.options.transformer = systemProviderConfig.transformer;
        }
      }
      
      // 处理模型配置，支持字符串和对象格式
      let models: (string | ModelInfo)[] = [];
      if (Array.isArray(provider.models)) {
        models = provider.models.map((model: any) => {
          if (typeof model === 'string') {
            return model;
          } else if (typeof model === 'object' && model.name) {
            return {
              name: model.name,
              maxTokens: model.maxTokens,
              ...model
            };
          }
          return String(model);
        });
      } else {
        models = [`${provider.name}-default-model`];
      }
      
      return {
        name: provider.name,
        priority: provider.priority || 1,
        api_base_url: provider.api_base_url,
        api_key: provider.api_key,
        maxTokens: provider.maxTokens,
        models: models,
        serverCompatibility: serverCompatibility
      };
    });
  }
  
  private static _generateRoutes(routerConfig: any, providers: ProviderInfo[]): RouteMapping {
    const routes: RouteMapping = {};
    
    for (const [routeName, routeValue] of Object.entries(routerConfig)) {
      if (typeof routeValue === 'string') {
        routes[routeName] = routeValue;
      }
    }
    
    if (!routes.default && providers.length > 0) {
      const firstProvider = providers[0];
      const firstModel = firstProvider.models[0];
      routes.default = `${firstProvider.name},${firstModel}`;
    }
    
    return routes;
  }
  
  private static _normalizeServerConfig(serverConfig: any): ServerInfo {
    return {
      port: serverConfig.port || 5506,
      host: serverConfig.host || '0.0.0.0',
      debug: serverConfig.debug || false
    };
  }
}