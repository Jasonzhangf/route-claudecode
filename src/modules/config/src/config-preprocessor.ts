import * as fs from 'fs';
import { ConfigPreprocessResult, RoutingTable, ProviderInfo, ServerInfo } from './routing-table-types';

export { ConfigPreprocessResult } from './routing-table-types';

export class ConfigPreprocessor {
  
  public static preprocess(configPath: string): ConfigPreprocessResult {
    const startTime = Date.now();
    const timestamp = new Date().toISOString();
    
    const rawConfig = ConfigPreprocessor._readConfigFile(configPath);
    const parsedConfig = ConfigPreprocessor._parseConfigContent(rawConfig);
    const providers = ConfigPreprocessor._expandProviders(parsedConfig.providers || []);
    const routes = ConfigPreprocessor._generateRoutes(parsedConfig.router || {}, providers);
    
    const routingTable: RoutingTable = {
      providers,
      routes,
      server: ConfigPreprocessor._normalizeServerConfig(parsedConfig.server || {}),
      apiKey: parsedConfig.APIKEY || parsedConfig.apiKey || 'default-key',
      version: '4.1.0',
      description: 'Generated by ConfigPreprocessor',
      lastUpdated: timestamp
    };
    
    return {
      success: true,
      routingTable: routingTable,
      metadata: {
        configPath,
        processingTime: Date.now() - startTime,
        timestamp,
        sourceFormat: 'v4'
      }
    };
  }
  
  private static _readConfigFile(configPath: string): string {
    return fs.readFileSync(configPath, 'utf8');
  }
  
  private static _parseConfigContent(content: string): any {
    return JSON.parse(content);
  }
  
  private static _expandProviders(providers: any[]): ProviderInfo[] {
    const expandedProviders: ProviderInfo[] = [];
    
    for (const provider of providers) {
      const expandedProvider: ProviderInfo = {
        name: provider.name,
        api_base_url: provider.api_base_url,
        api_key: provider.api_key || '',
        priority: provider.priority || 1,
        models: Array.isArray(provider.models) ? provider.models : [provider.model || 'default']
      };
      
      expandedProviders.push(expandedProvider);
    }
    
    return expandedProviders.sort((a, b) => (b.priority || 0) - (a.priority || 0));
  }
  
  private static _generateRoutes(routerConfig: any, providers: ProviderInfo[]): Record<string, string> {
    const routes: Record<string, string> = {};
    
    if (routerConfig.rules && Array.isArray(routerConfig.rules)) {
      for (const rule of routerConfig.rules) {
        if (rule.virtualModel && rule.targetProvider) {
          routes[rule.virtualModel] = `${rule.targetProvider},${rule.targetModel || 'default'}`;
        }
      }
    }
    
    if (routerConfig.mapping) {
      for (const [virtualModel, target] of Object.entries(routerConfig.mapping)) {
        routes[virtualModel] = target as string;
      }
    }
    
    if (Object.keys(routes).length === 0) {
      for (const provider of providers) {
        for (const model of provider.models) {
          const virtualModel = `${provider.name}-${model}`;
          routes[virtualModel] = `${provider.name},${model}`;
        }
      }
    }
    
    return routes;
  }
  
  private static _normalizeServerConfig(serverConfig: any): ServerInfo {
    return {
      port: serverConfig.port || 5506,
      host: serverConfig.host || '0.0.0.0',
      debug: serverConfig.debug === true
    };
  }
}