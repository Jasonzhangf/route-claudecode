/**
 * ğŸ­ Client Simulation Replay Engine - v3.0 Architecture
 * 
 * å®Œæ•´çš„åŸºäºå½•åˆ¶æ•°æ®çš„å®¢æˆ·ç«¯æ¨¡æ‹Ÿå›æ”¾å¼•æ“
 * æ”¯æŒå·¥å…·è°ƒç”¨è¿”å›å€¼ã€å“åº”æ•°æ®çš„ç²¾ç¡®é‡ç°
 * 
 * Features:
 * - åŸºäºå½•åˆ¶æ•°æ®çš„å®Œæ•´å®¢æˆ·ç«¯è¡Œä¸ºæ¨¡æ‹Ÿ
 * - å·¥å…·è°ƒç”¨è¿”å›å€¼è‡ªåŠ¨æ¨¡æ‹Ÿ
 * - ç«¯åˆ°ç«¯å“åº”é“¾å®Œæ•´é‡ç°
 * - æ—¶åºæ§åˆ¶å’Œå›æ”¾é€Ÿåº¦è°ƒèŠ‚
 * - å¹¶è¡Œ/ä¸²è¡Œå›æ”¾æ¨¡å¼
 * 
 * @author Jason Zhang
 * @version v3.0-refactor
 * @created 2025-08-13
 */

import fs from 'fs';
import path from 'path';
import os from 'os';
import { v4 as uuidv4 } from 'uuid';
import { EventEmitter } from 'events';

/**
 * Client Simulation Replay Engine
 * å®Œæ•´çš„å®¢æˆ·ç«¯è¡Œä¸ºæ¨¡æ‹Ÿå’Œé‡ç°å¼•æ“
 */
export class ClientSimulationReplayEngine extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.replayId = uuidv4();
        this.databasePath = path.join(os.homedir(), '.route-claudecode', 'database');
        this.outputPath = path.join(this.databasePath, 'replay', 'simulation-output');
        
        // å›æ”¾çŠ¶æ€ç®¡ç†
        this.state = 'idle'; // idle, running, paused, completed, error
        this.currentSession = null;
        this.replaySpeed = 1.0;
        this.currentStep = 0;
        this.totalSteps = 0;
        
        // å®¢æˆ·ç«¯æ¨¡æ‹ŸçŠ¶æ€
        this.simulatedClient = new SimulatedClient();
        this.toolCallRegistry = new Map(); // è®°å½•å·¥å…·è°ƒç”¨å’Œè¿”å›å€¼
        this.responseChain = []; // å®Œæ•´çš„å“åº”é“¾
        
        // é…ç½®é€‰é¡¹
        this.options = {
            strictTiming: false, // æ˜¯å¦ä¸¥æ ¼æŒ‰ç…§å½•åˆ¶æ—¶é—´æ‰§è¡Œ
            parallelExecution: false, // æ˜¯å¦å¹¶è¡Œæ‰§è¡Œå¤šä¸ªå›æ”¾
            toolCallSimulation: true, // æ˜¯å¦æ¨¡æ‹Ÿå·¥å…·è°ƒç”¨
            clientResponseSimulation: true, // æ˜¯å¦æ¨¡æ‹Ÿå®¢æˆ·ç«¯å“åº”
            ...options
        };
        
        this.initializeEngine();
    }
    
    /**
     * åˆå§‹åŒ–å›æ”¾å¼•æ“
     */
    initializeEngine() {
        // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        if (!fs.existsSync(this.outputPath)) {
            fs.mkdirSync(this.outputPath, { recursive: true });
        }
        
        console.log(`ğŸ­ Client Simulation Replay Engine initialized`);
        console.log(`   Replay ID: ${this.replayId}`);
        console.log(`   Database: ${this.databasePath}`);
        console.log(`   Options:`, this.options);
    }
    
    /**
     * å¼€å§‹å›æ”¾æŒ‡å®šçš„å½•åˆ¶ä¼šè¯
     * @param {string} sessionId - è¦å›æ”¾çš„ä¼šè¯ID
     * @param {object} replayConfig - å›æ”¾é…ç½®
     */
    async startSessionReplay(sessionId, replayConfig = {}) {
        try {
            console.log(`ğŸ¬ å¼€å§‹ä¼šè¯å›æ”¾: ${sessionId}`);
            
            this.state = 'running';
            this.currentSession = sessionId;
            this.emit('replayStarted', { sessionId, replayId: this.replayId });
            
            // åŠ è½½ä¼šè¯çš„æ‰€æœ‰å½•åˆ¶æ•°æ®
            const sessionData = await this.loadSessionData(sessionId);
            if (!sessionData) {
                throw new Error(`Session data not found: ${sessionId}`);
            }
            
            console.log(`ğŸ“š åŠ è½½ä¼šè¯æ•°æ®: ${sessionData.records.length} æ¡è®°å½•`);
            this.totalSteps = sessionData.records.length;
            
            // åˆ†æå½•åˆ¶æ•°æ®ï¼Œæ„å»ºå®Œæ•´çš„äº¤äº’é“¾
            const interactionChain = this.buildInteractionChain(sessionData.records);
            console.log(`ğŸ”— æ„å»ºäº¤äº’é“¾: ${interactionChain.length} ä¸ªäº¤äº’èŠ‚ç‚¹`);
            
            // æ‰§è¡Œå®Œæ•´çš„å®¢æˆ·ç«¯æ¨¡æ‹Ÿå›æ”¾
            const replayResult = await this.executeClientSimulationReplay(interactionChain, replayConfig);
            
            this.state = 'completed';
            this.emit('replayCompleted', replayResult);
            
            console.log(`âœ… å®¢æˆ·ç«¯æ¨¡æ‹Ÿå›æ”¾å®Œæˆ`);
            return replayResult;
            
        } catch (error) {
            this.state = 'error';
            this.emit('replayError', { error: error.message, sessionId });
            console.error(`âŒ å›æ”¾å¤±è´¥:`, error);
            throw error;
        }\n    }\n    \n    /**\n     * åŠ è½½æŒ‡å®šä¼šè¯çš„æ‰€æœ‰å½•åˆ¶æ•°æ®\n     * @param {string} sessionId - ä¼šè¯ID\n     */\n    async loadSessionData(sessionId) {\n        // æŸ¥æ‰¾åŒ¹é…çš„åœºæ™¯æ–‡ä»¶\n        const replayDir = path.join(this.databasePath, 'replay');\n        const scenarioFiles = fs.readdirSync(replayDir)\n            .filter(file => file.startsWith('scenario-') && file.endsWith('.json'));\n        \n        for (const file of scenarioFiles) {\n            try {\n                const scenarioPath = path.join(replayDir, file);\n                const scenario = JSON.parse(fs.readFileSync(scenarioPath, 'utf8'));\n                \n                if (scenario.sessionId === sessionId) {\n                    // åŠ è½½æ‰€æœ‰ç›¸å…³çš„æ•°æ®æ–‡ä»¶\n                    const records = [];\n                    \n                    for (const record of scenario.records) {\n                        if (fs.existsSync(record.filePath)) {\n                            const recordData = JSON.parse(fs.readFileSync(record.filePath, 'utf8'));\n                            records.push({\n                                ...record,\n                                data: recordData.data,\n                                metadata: recordData.metadata,\n                                timestamp: recordData.timestamp\n                            });\n                        }\n                    }\n                    \n                    return {\n                        ...scenario,\n                        records: records.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))\n                    };\n                }\n            } catch (error) {\n                console.warn(`Failed to load scenario ${file}:`, error.message);\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * æ„å»ºå®Œæ•´çš„äº¤äº’é“¾ï¼Œåˆ†ææ•°æ®æµå’Œå·¥å…·è°ƒç”¨å…³ç³»\n     * @param {array} records - å½•åˆ¶çš„æ•°æ®è®°å½•\n     */\n    buildInteractionChain(records) {\n        const chain = [];\n        let currentInteraction = null;\n        \n        // æŒ‰å±‚çº§å’Œæ“ä½œç±»å‹ç»„ç»‡æ•°æ®\n        const layerGroups = new Map();\n        \n        records.forEach(record => {\n            const layerKey = `${record.layer}-${record.operation}`;\n            if (!layerGroups.has(layerKey)) {\n                layerGroups.set(layerKey, []);\n            }\n            layerGroups.get(layerKey).push(record);\n        });\n        \n        // æ„å»ºå…­å±‚æ¶æ„çš„å®Œæ•´äº¤äº’é“¾\n        const layerOrder = [\n            'client-input', 'client-output',\n            'router-input', 'router-output',\n            'post-processor-input', 'post-processor-output',\n            'transformer-input', 'transformer-output',\n            'provider-protocol-input', 'provider-protocol-output',\n            'preprocessor-input', 'preprocessor-output',\n            'server-input', 'server-output'\n        ];\n        \n        layerOrder.forEach((layerKey, index) => {\n            const records = layerGroups.get(layerKey) || [];\n            \n            records.forEach(record => {\n                const interaction = {\n                    id: uuidv4(),\n                    step: index + 1,\n                    layer: record.layer,\n                    operation: record.operation,\n                    recordId: record.recordId,\n                    data: record.data,\n                    metadata: record.metadata,\n                    timestamp: record.timestamp,\n                    \n                    // å®¢æˆ·ç«¯æ¨¡æ‹Ÿç›¸å…³\n                    requiresClientSimulation: this.needsClientSimulation(record),\n                    toolCalls: this.extractToolCalls(record.data),\n                    expectedResponse: this.extractExpectedResponse(record.data),\n                    \n                    // å›æ”¾æ§åˆ¶\n                    simulationDelay: this.calculateSimulationDelay(record, index),\n                    canParallel: this.canExecuteInParallel(record)\n                };\n                \n                chain.push(interaction);\n                \n                // è®°å½•å·¥å…·è°ƒç”¨ä¿¡æ¯\n                if (interaction.toolCalls.length > 0) {\n                    interaction.toolCalls.forEach(toolCall => {\n                        this.toolCallRegistry.set(toolCall.id, {\n                            ...toolCall,\n                            interactionId: interaction.id,\n                            recordedResult: this.findToolCallResult(toolCall, records)\n                        });\n                    });\n                }\n            });\n        });\n        \n        return chain;\n    }\n    \n    /**\n     * æ‰§è¡Œå®Œæ•´çš„å®¢æˆ·ç«¯æ¨¡æ‹Ÿå›æ”¾\n     * @param {array} interactionChain - äº¤äº’é“¾\n     * @param {object} config - å›æ”¾é…ç½®\n     */\n    async executeClientSimulationReplay(interactionChain, config) {\n        const startTime = Date.now();\n        const results = {\n            replayId: this.replayId,\n            sessionId: this.currentSession,\n            startTime: new Date().toISOString(),\n            totalInteractions: interactionChain.length,\n            completedInteractions: 0,\n            clientSimulations: 0,\n            toolCallSimulations: 0,\n            errors: [],\n            executionDetails: []\n        };\n        \n        console.log(`ğŸ­ å¼€å§‹æ‰§è¡Œå®¢æˆ·ç«¯æ¨¡æ‹Ÿå›æ”¾`);\n        console.log(`   æ€»äº¤äº’æ•°: ${interactionChain.length}`);\n        console.log(`   å›æ”¾æ¨¡å¼: ${this.options.parallelExecution ? 'å¹¶è¡Œ' : 'ä¸²è¡Œ'}`);\n        \n        // æ‰§è¡Œäº¤äº’é“¾\n        if (this.options.parallelExecution) {\n            await this.executeParallelReplay(interactionChain, results);\n        } else {\n            await this.executeSequentialReplay(interactionChain, results);\n        }\n        \n        // å®Œæˆå›æ”¾ç»Ÿè®¡\n        results.endTime = new Date().toISOString();\n        results.totalDuration = Date.now() - startTime;\n        results.successRate = (results.completedInteractions / results.totalInteractions) * 100;\n        \n        // ä¿å­˜å›æ”¾ç»“æœ\n        await this.saveReplayResults(results);\n        \n        console.log(`ğŸ‰ å®¢æˆ·ç«¯æ¨¡æ‹Ÿå›æ”¾å®Œæˆ`);\n        console.log(`   æˆåŠŸç‡: ${results.successRate.toFixed(1)}%`);\n        console.log(`   å®¢æˆ·ç«¯æ¨¡æ‹Ÿ: ${results.clientSimulations} æ¬¡`);\n        console.log(`   å·¥å…·è°ƒç”¨æ¨¡æ‹Ÿ: ${results.toolCallSimulations} æ¬¡`);\n        \n        return results;\n    }\n    \n    /**\n     * ä¸²è¡Œæ‰§è¡Œå›æ”¾ï¼ˆæŒ‰æ—¶åºæ‰§è¡Œï¼‰\n     * @param {array} interactionChain - äº¤äº’é“¾\n     * @param {object} results - ç»“æœå¯¹è±¡\n     */\n    async executeSequentialReplay(interactionChain, results) {\n        for (let i = 0; i < interactionChain.length; i++) {\n            if (this.state !== 'running') break;\n            \n            const interaction = interactionChain[i];\n            this.currentStep = i + 1;\n            \n            try {\n                console.log(`ğŸ”„ [${this.currentStep}/${this.totalSteps}] ${interaction.layer}-${interaction.operation}`);\n                \n                const executionResult = await this.executeInteraction(interaction);\n                \n                results.executionDetails.push(executionResult);\n                results.completedInteractions++;\n                \n                if (executionResult.clientSimulated) {\n                    results.clientSimulations++;\n                }\n                if (executionResult.toolCallsSimulated > 0) {\n                    results.toolCallSimulations += executionResult.toolCallsSimulated;\n                }\n                \n                // æ¨¡æ‹Ÿæ—¶åºå»¶è¿Ÿ\n                if (this.options.strictTiming && interaction.simulationDelay > 0) {\n                    await this.delay(interaction.simulationDelay / this.replaySpeed);\n                }\n                \n                this.emit('interactionCompleted', {\n                    interaction,\n                    result: executionResult,\n                    progress: (this.currentStep / this.totalSteps) * 100\n                });\n                \n            } catch (error) {\n                console.error(`âŒ [${this.currentStep}] äº¤äº’æ‰§è¡Œå¤±è´¥:`, error.message);\n                results.errors.push({\n                    step: this.currentStep,\n                    interaction: interaction.id,\n                    error: error.message,\n                    timestamp: new Date().toISOString()\n                });\n            }\n        }\n    }\n    \n    /**\n     * å¹¶è¡Œæ‰§è¡Œå›æ”¾ï¼ˆå¯å¹¶è¡Œçš„äº¤äº’åŒæ—¶æ‰§è¡Œï¼‰\n     * @param {array} interactionChain - äº¤äº’é“¾\n     * @param {object} results - ç»“æœå¯¹è±¡\n     */\n    async executeParallelReplay(interactionChain, results) {\n        const batches = this.groupInteractionsForParallel(interactionChain);\n        \n        for (const batch of batches) {\n            if (this.state !== 'running') break;\n            \n            console.log(`ğŸ”„ å¹¶è¡Œæ‰§è¡Œæ‰¹æ¬¡: ${batch.length} ä¸ªäº¤äº’`);\n            \n            const batchPromises = batch.map(async interaction => {\n                try {\n                    return await this.executeInteraction(interaction);\n                } catch (error) {\n                    console.error(`âŒ å¹¶è¡Œäº¤äº’å¤±è´¥:`, error.message);\n                    results.errors.push({\n                        interaction: interaction.id,\n                        error: error.message,\n                        timestamp: new Date().toISOString()\n                    });\n                    return null;\n                }\n            });\n            \n            const batchResults = await Promise.all(batchPromises);\n            \n            batchResults.forEach(result => {\n                if (result) {\n                    results.executionDetails.push(result);\n                    results.completedInteractions++;\n                    if (result.clientSimulated) results.clientSimulations++;\n                    if (result.toolCallsSimulated > 0) results.toolCallSimulations += result.toolCallsSimulated;\n                }\n            });\n        }\n    }\n    \n    /**\n     * æ‰§è¡Œå•ä¸ªäº¤äº’çš„æ¨¡æ‹Ÿ\n     * @param {object} interaction - äº¤äº’å¯¹è±¡\n     */\n    async executeInteraction(interaction) {\n        const executionResult = {\n            interactionId: interaction.id,\n            layer: interaction.layer,\n            operation: interaction.operation,\n            startTime: Date.now(),\n            clientSimulated: false,\n            toolCallsSimulated: 0,\n            responseSimulated: false,\n            simulationDetails: {},\n            endTime: null,\n            duration: 0\n        };\n        \n        // 1. æ¨¡æ‹Ÿå®¢æˆ·ç«¯è¡Œä¸ºï¼ˆå¦‚æœéœ€è¦ï¼‰\n        if (interaction.requiresClientSimulation && this.options.clientResponseSimulation) {\n            executionResult.simulationDetails.clientSimulation = await this.simulatedClient.simulateClientBehavior(\n                interaction.layer,\n                interaction.data,\n                interaction.metadata\n            );\n            executionResult.clientSimulated = true;\n            console.log(`   ğŸ­ å®¢æˆ·ç«¯è¡Œä¸ºæ¨¡æ‹Ÿ: ${interaction.layer}`);\n        }\n        \n        // 2. æ¨¡æ‹Ÿå·¥å…·è°ƒç”¨è¿”å›ï¼ˆå¦‚æœæœ‰ï¼‰\n        if (interaction.toolCalls.length > 0 && this.options.toolCallSimulation) {\n            for (const toolCall of interaction.toolCalls) {\n                const toolResult = await this.simulateToolCallResponse(toolCall);\n                executionResult.simulationDetails.toolCalls = executionResult.simulationDetails.toolCalls || [];\n                executionResult.simulationDetails.toolCalls.push(toolResult);\n                executionResult.toolCallsSimulated++;\n                \n                console.log(`   ğŸ”§ å·¥å…·è°ƒç”¨æ¨¡æ‹Ÿ: ${toolCall.name}`);\n            }\n        }\n        \n        // 3. æ¨¡æ‹Ÿé¢„æœŸå“åº”\n        if (interaction.expectedResponse && interaction.operation === 'output') {\n            executionResult.simulationDetails.responseSimulation = {\n                originalResponse: interaction.expectedResponse,\n                simulatedResponse: interaction.data, // ä½¿ç”¨å½•åˆ¶çš„çœŸå®æ•°æ®\n                match: true\n            };\n            executionResult.responseSimulated = true;\n        }\n        \n        // 4. è®°å½•æ‰§è¡Œå®Œæˆ\n        executionResult.endTime = Date.now();\n        executionResult.duration = executionResult.endTime - executionResult.startTime;\n        \n        return executionResult;\n    }\n    \n    /**\n     * æ¨¡æ‹Ÿå·¥å…·è°ƒç”¨å“åº”\n     * @param {object} toolCall - å·¥å…·è°ƒç”¨ä¿¡æ¯\n     */\n    async simulateToolCallResponse(toolCall) {\n        // ä»æ³¨å†Œè¡¨ä¸­è·å–å½•åˆ¶çš„å·¥å…·è°ƒç”¨ç»“æœ\n        const registeredCall = this.toolCallRegistry.get(toolCall.id);\n        \n        if (registeredCall && registeredCall.recordedResult) {\n            // ä½¿ç”¨å½•åˆ¶çš„çœŸå®ç»“æœ\n            console.log(`   ğŸ“ ä½¿ç”¨å½•åˆ¶çš„å·¥å…·è°ƒç”¨ç»“æœ: ${toolCall.name}`);\n            return {\n                toolCallId: toolCall.id,\n                toolName: toolCall.name,\n                simulationType: 'recorded',\n                result: registeredCall.recordedResult,\n                executionTime: registeredCall.recordedResult.executionTime || 0\n            };\n        } else {\n            // æ ¹æ®å·¥å…·ç±»å‹ç”Ÿæˆæ¨¡æ‹Ÿç»“æœ\n            console.log(`   ğŸ² ç”Ÿæˆæ¨¡æ‹Ÿå·¥å…·è°ƒç”¨ç»“æœ: ${toolCall.name}`);\n            const simulatedResult = this.generateToolCallResult(toolCall);\n            \n            return {\n                toolCallId: toolCall.id,\n                toolName: toolCall.name,\n                simulationType: 'generated',\n                result: simulatedResult,\n                executionTime: Math.floor(Math.random() * 1000) + 100 // 100-1100ms\n            };\n        }\n    }\n    \n    /**\n     * ç”Ÿæˆå·¥å…·è°ƒç”¨çš„æ¨¡æ‹Ÿç»“æœ\n     * @param {object} toolCall - å·¥å…·è°ƒç”¨ä¿¡æ¯\n     */\n    generateToolCallResult(toolCall) {\n        const toolResultGenerators = {\n            'file_read': () => ({\n                success: true,\n                content: `Simulated file content for ${toolCall.args?.file_path || 'unknown file'}`,\n                lines: 42\n            }),\n            'file_write': () => ({\n                success: true,\n                written: true,\n                path: toolCall.args?.file_path || 'simulated_file.txt'\n            }),\n            'bash_command': () => ({\n                success: true,\n                output: 'Simulated command output',\n                exitCode: 0\n            }),\n            'web_search': () => ({\n                success: true,\n                results: [{\n                    title: 'Simulated Search Result',\n                    url: 'https://simulated-search-result.com',\n                    snippet: 'This is a simulated search result snippet'\n                }]\n            })\n        };\n        \n        const generator = toolResultGenerators[toolCall.name] || (() => ({\n            success: true,\n            message: `Simulated result for ${toolCall.name}`,\n            data: toolCall.args\n        }));\n        \n        return generator();\n    }\n    \n    /**\n     * åˆ¤æ–­è®°å½•æ˜¯å¦éœ€è¦å®¢æˆ·ç«¯æ¨¡æ‹Ÿ\n     * @param {object} record - æ•°æ®è®°å½•\n     */\n    needsClientSimulation(record) {\n        // å®¢æˆ·ç«¯å±‚çš„è¾“å…¥è¾“å‡ºéœ€è¦æ¨¡æ‹Ÿ\n        if (record.layer === 'client') return true;\n        \n        // åŒ…å«å·¥å…·è°ƒç”¨çš„è®°å½•éœ€è¦æ¨¡æ‹Ÿ\n        if (this.extractToolCalls(record.data).length > 0) return true;\n        \n        // æœåŠ¡å™¨å±‚çš„è¾“å‡ºéœ€è¦æ¨¡æ‹Ÿå®¢æˆ·ç«¯æ¥æ”¶\n        if (record.layer === 'server' && record.operation === 'output') return true;\n        \n        return false;\n    }\n    \n    /**\n     * ä»æ•°æ®ä¸­æå–å·¥å…·è°ƒç”¨ä¿¡æ¯\n     * @param {any} data - æ•°æ®å¯¹è±¡\n     */\n    extractToolCalls(data) {\n        const toolCalls = [];\n        \n        if (!data || typeof data !== 'object') return toolCalls;\n        \n        // æ£€æŸ¥å¸¸è§çš„å·¥å…·è°ƒç”¨å­—æ®µ\n        const toolCallFields = ['tool_calls', 'toolCalls', 'tools', 'function_calls'];\n        \n        for (const field of toolCallFields) {\n            if (data[field] && Array.isArray(data[field])) {\n                data[field].forEach((call, index) => {\n                    toolCalls.push({\n                        id: call.id || `tool-${index}`,\n                        name: call.name || call.function?.name || 'unknown_tool',\n                        args: call.args || call.function?.arguments || call.parameters || {},\n                        type: call.type || 'function'\n                    });\n                });\n            }\n        }\n        \n        return toolCalls;\n    }\n    \n    /**\n     * ä»æ•°æ®ä¸­æå–é¢„æœŸå“åº”\n     * @param {any} data - æ•°æ®å¯¹è±¡\n     */\n    extractExpectedResponse(data) {\n        if (!data || typeof data !== 'object') return null;\n        \n        // æŸ¥æ‰¾å“åº”ç›¸å…³å­—æ®µ\n        const responseFields = ['response', 'result', 'output', 'content', 'message'];\n        \n        for (const field of responseFields) {\n            if (data[field] !== undefined) {\n                return data[field];\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * è®¡ç®—æ¨¡æ‹Ÿå»¶è¿Ÿæ—¶é—´\n     * @param {object} record - æ•°æ®è®°å½•\n     * @param {number} index - ç´¢å¼•\n     */\n    calculateSimulationDelay(record, index) {\n        // åŸºäºå±‚çº§è®¾ç½®ä¸åŒçš„åŸºç¡€å»¶è¿Ÿ\n        const layerDelays = {\n            'client': 50,\n            'router': 10,\n            'post-processor': 20,\n            'transformer': 30,\n            'provider-protocol': 200,\n            'preprocessor': 100,\n            'server': 50\n        };\n        \n        const baseDelay = layerDelays[record.layer] || 50;\n        \n        // å·¥å…·è°ƒç”¨éœ€è¦æ›´é•¿æ—¶é—´\n        const toolCallDelay = this.extractToolCalls(record.data).length * 500;\n        \n        return baseDelay + toolCallDelay;\n    }\n    \n    /**\n     * åˆ¤æ–­æ˜¯å¦å¯ä»¥å¹¶è¡Œæ‰§è¡Œ\n     * @param {object} record - æ•°æ®è®°å½•\n     */\n    canExecuteInParallel(record) {\n        // æŸäº›æ“ä½œå¿…é¡»æŒ‰é¡ºåºæ‰§è¡Œ\n        const sequentialLayers = ['client', 'server'];\n        const sequentialOperations = ['input', 'output'];\n        \n        if (sequentialLayers.includes(record.layer)) return false;\n        if (sequentialOperations.includes(record.operation)) return false;\n        \n        return true;\n    }\n    \n    /**\n     * ä¸ºå¹¶è¡Œæ‰§è¡Œåˆ†ç»„äº¤äº’\n     * @param {array} interactions - äº¤äº’åˆ—è¡¨\n     */\n    groupInteractionsForParallel(interactions) {\n        const batches = [];\n        let currentBatch = [];\n        \n        interactions.forEach(interaction => {\n            if (interaction.canParallel && currentBatch.length < 3) {\n                currentBatch.push(interaction);\n            } else {\n                if (currentBatch.length > 0) {\n                    batches.push(currentBatch);\n                    currentBatch = [];\n                }\n                batches.push([interaction]); // å•ç‹¬æ‰¹æ¬¡\n            }\n        });\n        \n        if (currentBatch.length > 0) {\n            batches.push(currentBatch);\n        }\n        \n        return batches;\n    }\n    \n    /**\n     * æŸ¥æ‰¾å·¥å…·è°ƒç”¨çš„ç»“æœ\n     * @param {object} toolCall - å·¥å…·è°ƒç”¨\n     * @param {array} records - æ‰€æœ‰è®°å½•\n     */\n    findToolCallResult(toolCall, records) {\n        // åœ¨åç»­è®°å½•ä¸­æŸ¥æ‰¾åŒ¹é…çš„å·¥å…·è°ƒç”¨ç»“æœ\n        for (const record of records) {\n            if (record.data && record.data.tool_results) {\n                const result = record.data.tool_results.find(r => \n                    r.tool_call_id === toolCall.id || \n                    r.name === toolCall.name\n                );\n                if (result) return result;\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * ä¿å­˜å›æ”¾ç»“æœ\n     * @param {object} results - å›æ”¾ç»“æœ\n     */\n    async saveReplayResults(results) {\n        const resultsFile = path.join(\n            this.outputPath, \n            `client-simulation-replay-${this.replayId}-${Date.now()}.json`\n        );\n        \n        try {\n            fs.writeFileSync(resultsFile, JSON.stringify(results, null, 2));\n            console.log(`ğŸ’¾ å›æ”¾ç»“æœå·²ä¿å­˜: ${resultsFile}`);\n        } catch (error) {\n            console.error(`âŒ ä¿å­˜å›æ”¾ç»“æœå¤±è´¥:`, error);\n        }\n    }\n    \n    /**\n     * å»¶è¿Ÿå‡½æ•°\n     * @param {number} ms - å»¶è¿Ÿæ¯«ç§’æ•°\n     */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    /**\n     * è·å–å›æ”¾çŠ¶æ€\n     */\n    getReplayStatus() {\n        return {\n            replayId: this.replayId,\n            state: this.state,\n            currentSession: this.currentSession,\n            currentStep: this.currentStep,\n            totalSteps: this.totalSteps,\n            progress: this.totalSteps > 0 ? (this.currentStep / this.totalSteps) * 100 : 0,\n            speed: this.replaySpeed,\n            toolCallRegistry: this.toolCallRegistry.size,\n            options: this.options\n        };\n    }\n    \n    /**\n     * æš‚åœå›æ”¾\n     */\n    pause() {\n        if (this.state === 'running') {\n            this.state = 'paused';\n            this.emit('replayPaused', { replayId: this.replayId });\n            console.log(`â¸ï¸ å›æ”¾å·²æš‚åœ`);\n        }\n    }\n    \n    /**\n     * æ¢å¤å›æ”¾\n     */\n    resume() {\n        if (this.state === 'paused') {\n            this.state = 'running';\n            this.emit('replayResumed', { replayId: this.replayId });\n            console.log(`â–¶ï¸ å›æ”¾å·²æ¢å¤`);\n        }\n    }\n    \n    /**\n     * åœæ­¢å›æ”¾\n     */\n    stop() {\n        this.state = 'stopped';\n        this.emit('replayStopped', { replayId: this.replayId });\n        console.log(`â¹ï¸ å›æ”¾å·²åœæ­¢`);\n    }\n    \n    /**\n     * è®¾ç½®å›æ”¾é€Ÿåº¦\n     * @param {number} speed - é€Ÿåº¦å€ç‡ (0.1 - 5.0)\n     */\n    setSpeed(speed) {\n        if (speed >= 0.1 && speed <= 5.0) {\n            this.replaySpeed = speed;\n            console.log(`âš¡ å›æ”¾é€Ÿåº¦è®¾ç½®ä¸º: ${speed}x`);\n        }\n    }\n}\n\n/**\n * æ¨¡æ‹Ÿå®¢æˆ·ç«¯ç±»\n * è´Ÿè´£æ¨¡æ‹ŸçœŸå®å®¢æˆ·ç«¯çš„è¡Œä¸ºå’Œå“åº”\n */\nexport class SimulatedClient {\n    constructor() {\n        this.clientState = new Map();\n        this.responseHistory = [];\n    }\n    \n    /**\n     * æ¨¡æ‹Ÿå®¢æˆ·ç«¯è¡Œä¸º\n     * @param {string} layer - å±‚çº§\n     * @param {any} data - æ•°æ®\n     * @param {object} metadata - å…ƒæ•°æ®\n     */\n    async simulateClientBehavior(layer, data, metadata) {\n        const behavior = {\n            timestamp: new Date().toISOString(),\n            layer,\n            simulationType: 'client-behavior',\n            originalData: data,\n            simulatedBehavior: {},\n            duration: 0\n        };\n        \n        const startTime = Date.now();\n        \n        switch (layer) {\n            case 'client':\n                behavior.simulatedBehavior = await this.simulateClientInteraction(data);\n                break;\n            case 'server':\n                behavior.simulatedBehavior = await this.simulateClientResponse(data);\n                break;\n            default:\n                behavior.simulatedBehavior = await this.simulateGenericBehavior(layer, data);\n        }\n        \n        behavior.duration = Date.now() - startTime;\n        this.responseHistory.push(behavior);\n        \n        return behavior;\n    }\n    \n    /**\n     * æ¨¡æ‹Ÿå®¢æˆ·ç«¯äº¤äº’\n     */\n    async simulateClientInteraction(data) {\n        // æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥å¤„ç†\n        return {\n            userInput: data.request || data.message || 'Simulated user input',\n            processed: true,\n            validationPassed: true,\n            clientTimestamp: new Date().toISOString()\n        };\n    }\n    \n    /**\n     * æ¨¡æ‹Ÿå®¢æˆ·ç«¯æ¥æ”¶å“åº”\n     */\n    async simulateClientResponse(data) {\n        // æ¨¡æ‹Ÿå®¢æˆ·ç«¯æ¥æ”¶å’Œå¤„ç†æœåŠ¡å™¨å“åº”\n        return {\n            responseReceived: true,\n            responseType: typeof data,\n            contentLength: JSON.stringify(data).length,\n            processingTime: Math.floor(Math.random() * 50) + 10,\n            displayReady: true\n        };\n    }\n    \n    /**\n     * æ¨¡æ‹Ÿé€šç”¨è¡Œä¸º\n     */\n    async simulateGenericBehavior(layer, data) {\n        return {\n            layer,\n            dataProcessed: true,\n            simulationTimestamp: new Date().toISOString(),\n            dataSize: JSON.stringify(data).length\n        };\n    }\n}\n\nexport default ClientSimulationReplayEngine;