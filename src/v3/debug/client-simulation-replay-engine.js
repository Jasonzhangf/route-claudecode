/**
 * 🎭 Client Simulation Replay Engine - v3.0 Architecture
 * 
 * 完整的基于录制数据的客户端模拟回放引擎
 * 支持工具调用返回值、响应数据的精确重现
 * 
 * Features:
 * - 基于录制数据的完整客户端行为模拟
 * - 工具调用返回值自动模拟
 * - 端到端响应链完整重现
 * - 时序控制和回放速度调节
 * - 并行/串行回放模式
 * 
 * @author Jason Zhang
 * @version v3.0-refactor
 * @created 2025-08-13
 */

import fs from 'fs';
import path from 'path';
import os from 'os';
import { v4 as uuidv4 } from 'uuid';
import { EventEmitter } from 'events';

/**
 * Client Simulation Replay Engine
 * 完整的客户端行为模拟和重现引擎
 */
export class ClientSimulationReplayEngine extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.replayId = uuidv4();
        this.databasePath = path.join(os.homedir(), '.route-claudecode', 'database');
        this.outputPath = path.join(this.databasePath, 'replay', 'simulation-output');
        
        // 回放状态管理
        this.state = 'idle'; // idle, running, paused, completed, error
        this.currentSession = null;
        this.replaySpeed = 1.0;
        this.currentStep = 0;
        this.totalSteps = 0;
        
        // 客户端模拟状态
        this.simulatedClient = new SimulatedClient();
        this.toolCallRegistry = new Map(); // 记录工具调用和返回值
        this.responseChain = []; // 完整的响应链
        
        // 配置选项
        this.options = {
            strictTiming: false, // 是否严格按照录制时间执行
            parallelExecution: false, // 是否并行执行多个回放
            toolCallSimulation: true, // 是否模拟工具调用
            clientResponseSimulation: true, // 是否模拟客户端响应
            ...options
        };
        
        this.initializeEngine();
    }
    
    /**
     * 初始化回放引擎
     */
    initializeEngine() {
        // 确保输出目录存在
        if (!fs.existsSync(this.outputPath)) {
            fs.mkdirSync(this.outputPath, { recursive: true });
        }
        
        console.log(`🎭 Client Simulation Replay Engine initialized`);
        console.log(`   Replay ID: ${this.replayId}`);
        console.log(`   Database: ${this.databasePath}`);
        console.log(`   Options:`, this.options);
    }
    
    /**
     * 开始回放指定的录制会话
     * @param {string} sessionId - 要回放的会话ID
     * @param {object} replayConfig - 回放配置
     */
    async startSessionReplay(sessionId, replayConfig = {}) {
        try {
            console.log(`🎬 开始会话回放: ${sessionId}`);
            
            this.state = 'running';
            this.currentSession = sessionId;
            this.emit('replayStarted', { sessionId, replayId: this.replayId });
            
            // 加载会话的所有录制数据
            const sessionData = await this.loadSessionData(sessionId);
            if (!sessionData) {
                throw new Error(`Session data not found: ${sessionId}`);
            }
            
            console.log(`📚 加载会话数据: ${sessionData.records.length} 条记录`);
            this.totalSteps = sessionData.records.length;
            
            // 分析录制数据，构建完整的交互链
            const interactionChain = this.buildInteractionChain(sessionData.records);
            console.log(`🔗 构建交互链: ${interactionChain.length} 个交互节点`);
            
            // 执行完整的客户端模拟回放
            const replayResult = await this.executeClientSimulationReplay(interactionChain, replayConfig);
            
            this.state = 'completed';
            this.emit('replayCompleted', replayResult);
            
            console.log(`✅ 客户端模拟回放完成`);
            return replayResult;
            
        } catch (error) {
            this.state = 'error';
            this.emit('replayError', { error: error.message, sessionId });
            console.error(`❌ 回放失败:`, error);
            throw error;
        }\n    }\n    \n    /**\n     * 加载指定会话的所有录制数据\n     * @param {string} sessionId - 会话ID\n     */\n    async loadSessionData(sessionId) {\n        // 查找匹配的场景文件\n        const replayDir = path.join(this.databasePath, 'replay');\n        const scenarioFiles = fs.readdirSync(replayDir)\n            .filter(file => file.startsWith('scenario-') && file.endsWith('.json'));\n        \n        for (const file of scenarioFiles) {\n            try {\n                const scenarioPath = path.join(replayDir, file);\n                const scenario = JSON.parse(fs.readFileSync(scenarioPath, 'utf8'));\n                \n                if (scenario.sessionId === sessionId) {\n                    // 加载所有相关的数据文件\n                    const records = [];\n                    \n                    for (const record of scenario.records) {\n                        if (fs.existsSync(record.filePath)) {\n                            const recordData = JSON.parse(fs.readFileSync(record.filePath, 'utf8'));\n                            records.push({\n                                ...record,\n                                data: recordData.data,\n                                metadata: recordData.metadata,\n                                timestamp: recordData.timestamp\n                            });\n                        }\n                    }\n                    \n                    return {\n                        ...scenario,\n                        records: records.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))\n                    };\n                }\n            } catch (error) {\n                console.warn(`Failed to load scenario ${file}:`, error.message);\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * 构建完整的交互链，分析数据流和工具调用关系\n     * @param {array} records - 录制的数据记录\n     */\n    buildInteractionChain(records) {\n        const chain = [];\n        let currentInteraction = null;\n        \n        // 按层级和操作类型组织数据\n        const layerGroups = new Map();\n        \n        records.forEach(record => {\n            const layerKey = `${record.layer}-${record.operation}`;\n            if (!layerGroups.has(layerKey)) {\n                layerGroups.set(layerKey, []);\n            }\n            layerGroups.get(layerKey).push(record);\n        });\n        \n        // 构建六层架构的完整交互链\n        const layerOrder = [\n            'client-input', 'client-output',\n            'router-input', 'router-output',\n            'post-processor-input', 'post-processor-output',\n            'transformer-input', 'transformer-output',\n            'provider-protocol-input', 'provider-protocol-output',\n            'preprocessor-input', 'preprocessor-output',\n            'server-input', 'server-output'\n        ];\n        \n        layerOrder.forEach((layerKey, index) => {\n            const records = layerGroups.get(layerKey) || [];\n            \n            records.forEach(record => {\n                const interaction = {\n                    id: uuidv4(),\n                    step: index + 1,\n                    layer: record.layer,\n                    operation: record.operation,\n                    recordId: record.recordId,\n                    data: record.data,\n                    metadata: record.metadata,\n                    timestamp: record.timestamp,\n                    \n                    // 客户端模拟相关\n                    requiresClientSimulation: this.needsClientSimulation(record),\n                    toolCalls: this.extractToolCalls(record.data),\n                    expectedResponse: this.extractExpectedResponse(record.data),\n                    \n                    // 回放控制\n                    simulationDelay: this.calculateSimulationDelay(record, index),\n                    canParallel: this.canExecuteInParallel(record)\n                };\n                \n                chain.push(interaction);\n                \n                // 记录工具调用信息\n                if (interaction.toolCalls.length > 0) {\n                    interaction.toolCalls.forEach(toolCall => {\n                        this.toolCallRegistry.set(toolCall.id, {\n                            ...toolCall,\n                            interactionId: interaction.id,\n                            recordedResult: this.findToolCallResult(toolCall, records)\n                        });\n                    });\n                }\n            });\n        });\n        \n        return chain;\n    }\n    \n    /**\n     * 执行完整的客户端模拟回放\n     * @param {array} interactionChain - 交互链\n     * @param {object} config - 回放配置\n     */\n    async executeClientSimulationReplay(interactionChain, config) {\n        const startTime = Date.now();\n        const results = {\n            replayId: this.replayId,\n            sessionId: this.currentSession,\n            startTime: new Date().toISOString(),\n            totalInteractions: interactionChain.length,\n            completedInteractions: 0,\n            clientSimulations: 0,\n            toolCallSimulations: 0,\n            errors: [],\n            executionDetails: []\n        };\n        \n        console.log(`🎭 开始执行客户端模拟回放`);\n        console.log(`   总交互数: ${interactionChain.length}`);\n        console.log(`   回放模式: ${this.options.parallelExecution ? '并行' : '串行'}`);\n        \n        // 执行交互链\n        if (this.options.parallelExecution) {\n            await this.executeParallelReplay(interactionChain, results);\n        } else {\n            await this.executeSequentialReplay(interactionChain, results);\n        }\n        \n        // 完成回放统计\n        results.endTime = new Date().toISOString();\n        results.totalDuration = Date.now() - startTime;\n        results.successRate = (results.completedInteractions / results.totalInteractions) * 100;\n        \n        // 保存回放结果\n        await this.saveReplayResults(results);\n        \n        console.log(`🎉 客户端模拟回放完成`);\n        console.log(`   成功率: ${results.successRate.toFixed(1)}%`);\n        console.log(`   客户端模拟: ${results.clientSimulations} 次`);\n        console.log(`   工具调用模拟: ${results.toolCallSimulations} 次`);\n        \n        return results;\n    }\n    \n    /**\n     * 串行执行回放（按时序执行）\n     * @param {array} interactionChain - 交互链\n     * @param {object} results - 结果对象\n     */\n    async executeSequentialReplay(interactionChain, results) {\n        for (let i = 0; i < interactionChain.length; i++) {\n            if (this.state !== 'running') break;\n            \n            const interaction = interactionChain[i];\n            this.currentStep = i + 1;\n            \n            try {\n                console.log(`🔄 [${this.currentStep}/${this.totalSteps}] ${interaction.layer}-${interaction.operation}`);\n                \n                const executionResult = await this.executeInteraction(interaction);\n                \n                results.executionDetails.push(executionResult);\n                results.completedInteractions++;\n                \n                if (executionResult.clientSimulated) {\n                    results.clientSimulations++;\n                }\n                if (executionResult.toolCallsSimulated > 0) {\n                    results.toolCallSimulations += executionResult.toolCallsSimulated;\n                }\n                \n                // 模拟时序延迟\n                if (this.options.strictTiming && interaction.simulationDelay > 0) {\n                    await this.delay(interaction.simulationDelay / this.replaySpeed);\n                }\n                \n                this.emit('interactionCompleted', {\n                    interaction,\n                    result: executionResult,\n                    progress: (this.currentStep / this.totalSteps) * 100\n                });\n                \n            } catch (error) {\n                console.error(`❌ [${this.currentStep}] 交互执行失败:`, error.message);\n                results.errors.push({\n                    step: this.currentStep,\n                    interaction: interaction.id,\n                    error: error.message,\n                    timestamp: new Date().toISOString()\n                });\n            }\n        }\n    }\n    \n    /**\n     * 并行执行回放（可并行的交互同时执行）\n     * @param {array} interactionChain - 交互链\n     * @param {object} results - 结果对象\n     */\n    async executeParallelReplay(interactionChain, results) {\n        const batches = this.groupInteractionsForParallel(interactionChain);\n        \n        for (const batch of batches) {\n            if (this.state !== 'running') break;\n            \n            console.log(`🔄 并行执行批次: ${batch.length} 个交互`);\n            \n            const batchPromises = batch.map(async interaction => {\n                try {\n                    return await this.executeInteraction(interaction);\n                } catch (error) {\n                    console.error(`❌ 并行交互失败:`, error.message);\n                    results.errors.push({\n                        interaction: interaction.id,\n                        error: error.message,\n                        timestamp: new Date().toISOString()\n                    });\n                    return null;\n                }\n            });\n            \n            const batchResults = await Promise.all(batchPromises);\n            \n            batchResults.forEach(result => {\n                if (result) {\n                    results.executionDetails.push(result);\n                    results.completedInteractions++;\n                    if (result.clientSimulated) results.clientSimulations++;\n                    if (result.toolCallsSimulated > 0) results.toolCallSimulations += result.toolCallsSimulated;\n                }\n            });\n        }\n    }\n    \n    /**\n     * 执行单个交互的模拟\n     * @param {object} interaction - 交互对象\n     */\n    async executeInteraction(interaction) {\n        const executionResult = {\n            interactionId: interaction.id,\n            layer: interaction.layer,\n            operation: interaction.operation,\n            startTime: Date.now(),\n            clientSimulated: false,\n            toolCallsSimulated: 0,\n            responseSimulated: false,\n            simulationDetails: {},\n            endTime: null,\n            duration: 0\n        };\n        \n        // 1. 模拟客户端行为（如果需要）\n        if (interaction.requiresClientSimulation && this.options.clientResponseSimulation) {\n            executionResult.simulationDetails.clientSimulation = await this.simulatedClient.simulateClientBehavior(\n                interaction.layer,\n                interaction.data,\n                interaction.metadata\n            );\n            executionResult.clientSimulated = true;\n            console.log(`   🎭 客户端行为模拟: ${interaction.layer}`);\n        }\n        \n        // 2. 模拟工具调用返回（如果有）\n        if (interaction.toolCalls.length > 0 && this.options.toolCallSimulation) {\n            for (const toolCall of interaction.toolCalls) {\n                const toolResult = await this.simulateToolCallResponse(toolCall);\n                executionResult.simulationDetails.toolCalls = executionResult.simulationDetails.toolCalls || [];\n                executionResult.simulationDetails.toolCalls.push(toolResult);\n                executionResult.toolCallsSimulated++;\n                \n                console.log(`   🔧 工具调用模拟: ${toolCall.name}`);\n            }\n        }\n        \n        // 3. 模拟预期响应\n        if (interaction.expectedResponse && interaction.operation === 'output') {\n            executionResult.simulationDetails.responseSimulation = {\n                originalResponse: interaction.expectedResponse,\n                simulatedResponse: interaction.data, // 使用录制的真实数据\n                match: true\n            };\n            executionResult.responseSimulated = true;\n        }\n        \n        // 4. 记录执行完成\n        executionResult.endTime = Date.now();\n        executionResult.duration = executionResult.endTime - executionResult.startTime;\n        \n        return executionResult;\n    }\n    \n    /**\n     * 模拟工具调用响应\n     * @param {object} toolCall - 工具调用信息\n     */\n    async simulateToolCallResponse(toolCall) {\n        // 从注册表中获取录制的工具调用结果\n        const registeredCall = this.toolCallRegistry.get(toolCall.id);\n        \n        if (registeredCall && registeredCall.recordedResult) {\n            // 使用录制的真实结果\n            console.log(`   📁 使用录制的工具调用结果: ${toolCall.name}`);\n            return {\n                toolCallId: toolCall.id,\n                toolName: toolCall.name,\n                simulationType: 'recorded',\n                result: registeredCall.recordedResult,\n                executionTime: registeredCall.recordedResult.executionTime || 0\n            };\n        } else {\n            // 根据工具类型生成模拟结果\n            console.log(`   🎲 生成模拟工具调用结果: ${toolCall.name}`);\n            const simulatedResult = this.generateToolCallResult(toolCall);\n            \n            return {\n                toolCallId: toolCall.id,\n                toolName: toolCall.name,\n                simulationType: 'generated',\n                result: simulatedResult,\n                executionTime: Math.floor(Math.random() * 1000) + 100 // 100-1100ms\n            };\n        }\n    }\n    \n    /**\n     * 生成工具调用的模拟结果\n     * @param {object} toolCall - 工具调用信息\n     */\n    generateToolCallResult(toolCall) {\n        const toolResultGenerators = {\n            'file_read': () => ({\n                success: true,\n                content: `Simulated file content for ${toolCall.args?.file_path || 'unknown file'}`,\n                lines: 42\n            }),\n            'file_write': () => ({\n                success: true,\n                written: true,\n                path: toolCall.args?.file_path || 'simulated_file.txt'\n            }),\n            'bash_command': () => ({\n                success: true,\n                output: 'Simulated command output',\n                exitCode: 0\n            }),\n            'web_search': () => ({\n                success: true,\n                results: [{\n                    title: 'Simulated Search Result',\n                    url: 'https://simulated-search-result.com',\n                    snippet: 'This is a simulated search result snippet'\n                }]\n            })\n        };\n        \n        const generator = toolResultGenerators[toolCall.name] || (() => ({\n            success: true,\n            message: `Simulated result for ${toolCall.name}`,\n            data: toolCall.args\n        }));\n        \n        return generator();\n    }\n    \n    /**\n     * 判断记录是否需要客户端模拟\n     * @param {object} record - 数据记录\n     */\n    needsClientSimulation(record) {\n        // 客户端层的输入输出需要模拟\n        if (record.layer === 'client') return true;\n        \n        // 包含工具调用的记录需要模拟\n        if (this.extractToolCalls(record.data).length > 0) return true;\n        \n        // 服务器层的输出需要模拟客户端接收\n        if (record.layer === 'server' && record.operation === 'output') return true;\n        \n        return false;\n    }\n    \n    /**\n     * 从数据中提取工具调用信息\n     * @param {any} data - 数据对象\n     */\n    extractToolCalls(data) {\n        const toolCalls = [];\n        \n        if (!data || typeof data !== 'object') return toolCalls;\n        \n        // 检查常见的工具调用字段\n        const toolCallFields = ['tool_calls', 'toolCalls', 'tools', 'function_calls'];\n        \n        for (const field of toolCallFields) {\n            if (data[field] && Array.isArray(data[field])) {\n                data[field].forEach((call, index) => {\n                    toolCalls.push({\n                        id: call.id || `tool-${index}`,\n                        name: call.name || call.function?.name || 'unknown_tool',\n                        args: call.args || call.function?.arguments || call.parameters || {},\n                        type: call.type || 'function'\n                    });\n                });\n            }\n        }\n        \n        return toolCalls;\n    }\n    \n    /**\n     * 从数据中提取预期响应\n     * @param {any} data - 数据对象\n     */\n    extractExpectedResponse(data) {\n        if (!data || typeof data !== 'object') return null;\n        \n        // 查找响应相关字段\n        const responseFields = ['response', 'result', 'output', 'content', 'message'];\n        \n        for (const field of responseFields) {\n            if (data[field] !== undefined) {\n                return data[field];\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * 计算模拟延迟时间\n     * @param {object} record - 数据记录\n     * @param {number} index - 索引\n     */\n    calculateSimulationDelay(record, index) {\n        // 基于层级设置不同的基础延迟\n        const layerDelays = {\n            'client': 50,\n            'router': 10,\n            'post-processor': 20,\n            'transformer': 30,\n            'provider-protocol': 200,\n            'preprocessor': 100,\n            'server': 50\n        };\n        \n        const baseDelay = layerDelays[record.layer] || 50;\n        \n        // 工具调用需要更长时间\n        const toolCallDelay = this.extractToolCalls(record.data).length * 500;\n        \n        return baseDelay + toolCallDelay;\n    }\n    \n    /**\n     * 判断是否可以并行执行\n     * @param {object} record - 数据记录\n     */\n    canExecuteInParallel(record) {\n        // 某些操作必须按顺序执行\n        const sequentialLayers = ['client', 'server'];\n        const sequentialOperations = ['input', 'output'];\n        \n        if (sequentialLayers.includes(record.layer)) return false;\n        if (sequentialOperations.includes(record.operation)) return false;\n        \n        return true;\n    }\n    \n    /**\n     * 为并行执行分组交互\n     * @param {array} interactions - 交互列表\n     */\n    groupInteractionsForParallel(interactions) {\n        const batches = [];\n        let currentBatch = [];\n        \n        interactions.forEach(interaction => {\n            if (interaction.canParallel && currentBatch.length < 3) {\n                currentBatch.push(interaction);\n            } else {\n                if (currentBatch.length > 0) {\n                    batches.push(currentBatch);\n                    currentBatch = [];\n                }\n                batches.push([interaction]); // 单独批次\n            }\n        });\n        \n        if (currentBatch.length > 0) {\n            batches.push(currentBatch);\n        }\n        \n        return batches;\n    }\n    \n    /**\n     * 查找工具调用的结果\n     * @param {object} toolCall - 工具调用\n     * @param {array} records - 所有记录\n     */\n    findToolCallResult(toolCall, records) {\n        // 在后续记录中查找匹配的工具调用结果\n        for (const record of records) {\n            if (record.data && record.data.tool_results) {\n                const result = record.data.tool_results.find(r => \n                    r.tool_call_id === toolCall.id || \n                    r.name === toolCall.name\n                );\n                if (result) return result;\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * 保存回放结果\n     * @param {object} results - 回放结果\n     */\n    async saveReplayResults(results) {\n        const resultsFile = path.join(\n            this.outputPath, \n            `client-simulation-replay-${this.replayId}-${Date.now()}.json`\n        );\n        \n        try {\n            fs.writeFileSync(resultsFile, JSON.stringify(results, null, 2));\n            console.log(`💾 回放结果已保存: ${resultsFile}`);\n        } catch (error) {\n            console.error(`❌ 保存回放结果失败:`, error);\n        }\n    }\n    \n    /**\n     * 延迟函数\n     * @param {number} ms - 延迟毫秒数\n     */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    /**\n     * 获取回放状态\n     */\n    getReplayStatus() {\n        return {\n            replayId: this.replayId,\n            state: this.state,\n            currentSession: this.currentSession,\n            currentStep: this.currentStep,\n            totalSteps: this.totalSteps,\n            progress: this.totalSteps > 0 ? (this.currentStep / this.totalSteps) * 100 : 0,\n            speed: this.replaySpeed,\n            toolCallRegistry: this.toolCallRegistry.size,\n            options: this.options\n        };\n    }\n    \n    /**\n     * 暂停回放\n     */\n    pause() {\n        if (this.state === 'running') {\n            this.state = 'paused';\n            this.emit('replayPaused', { replayId: this.replayId });\n            console.log(`⏸️ 回放已暂停`);\n        }\n    }\n    \n    /**\n     * 恢复回放\n     */\n    resume() {\n        if (this.state === 'paused') {\n            this.state = 'running';\n            this.emit('replayResumed', { replayId: this.replayId });\n            console.log(`▶️ 回放已恢复`);\n        }\n    }\n    \n    /**\n     * 停止回放\n     */\n    stop() {\n        this.state = 'stopped';\n        this.emit('replayStopped', { replayId: this.replayId });\n        console.log(`⏹️ 回放已停止`);\n    }\n    \n    /**\n     * 设置回放速度\n     * @param {number} speed - 速度倍率 (0.1 - 5.0)\n     */\n    setSpeed(speed) {\n        if (speed >= 0.1 && speed <= 5.0) {\n            this.replaySpeed = speed;\n            console.log(`⚡ 回放速度设置为: ${speed}x`);\n        }\n    }\n}\n\n/**\n * 模拟客户端类\n * 负责模拟真实客户端的行为和响应\n */\nexport class SimulatedClient {\n    constructor() {\n        this.clientState = new Map();\n        this.responseHistory = [];\n    }\n    \n    /**\n     * 模拟客户端行为\n     * @param {string} layer - 层级\n     * @param {any} data - 数据\n     * @param {object} metadata - 元数据\n     */\n    async simulateClientBehavior(layer, data, metadata) {\n        const behavior = {\n            timestamp: new Date().toISOString(),\n            layer,\n            simulationType: 'client-behavior',\n            originalData: data,\n            simulatedBehavior: {},\n            duration: 0\n        };\n        \n        const startTime = Date.now();\n        \n        switch (layer) {\n            case 'client':\n                behavior.simulatedBehavior = await this.simulateClientInteraction(data);\n                break;\n            case 'server':\n                behavior.simulatedBehavior = await this.simulateClientResponse(data);\n                break;\n            default:\n                behavior.simulatedBehavior = await this.simulateGenericBehavior(layer, data);\n        }\n        \n        behavior.duration = Date.now() - startTime;\n        this.responseHistory.push(behavior);\n        \n        return behavior;\n    }\n    \n    /**\n     * 模拟客户端交互\n     */\n    async simulateClientInteraction(data) {\n        // 模拟用户输入处理\n        return {\n            userInput: data.request || data.message || 'Simulated user input',\n            processed: true,\n            validationPassed: true,\n            clientTimestamp: new Date().toISOString()\n        };\n    }\n    \n    /**\n     * 模拟客户端接收响应\n     */\n    async simulateClientResponse(data) {\n        // 模拟客户端接收和处理服务器响应\n        return {\n            responseReceived: true,\n            responseType: typeof data,\n            contentLength: JSON.stringify(data).length,\n            processingTime: Math.floor(Math.random() * 50) + 10,\n            displayReady: true\n        };\n    }\n    \n    /**\n     * 模拟通用行为\n     */\n    async simulateGenericBehavior(layer, data) {\n        return {\n            layer,\n            dataProcessed: true,\n            simulationTimestamp: new Date().toISOString(),\n            dataSize: JSON.stringify(data).length\n        };\n    }\n}\n\nexport default ClientSimulationReplayEngine;