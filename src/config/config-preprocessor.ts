import * as fs from 'fs';
import { 
  RoutingTable, 
  ProviderInfo, 
  RouteMapping, 
  ServerInfo,
  ConfigPreprocessResult
} from './routing-table-types';

// Export the result type for external use
export { ConfigPreprocessResult } from './routing-table-types';
import { secureLogger } from '../utils/secure-logger';

export class ConfigPreprocessor {
  
  public static preprocess(configPath: string): ConfigPreprocessResult {
    const startTime = Date.now();
    const timestamp = new Date().toISOString();
    
    try {
      const rawConfig = ConfigPreprocessor._readConfigFile(configPath);
      const parsedConfig = ConfigPreprocessor._parseConfigContent(rawConfig);
      const providers = ConfigPreprocessor._expandProviders(parsedConfig.providers || []);
      const routes = ConfigPreprocessor._generateRoutes(parsedConfig.router || {}, providers);
      
      const routingTable: RoutingTable = {
        providers,
        routes,
        server: ConfigPreprocessor._normalizeServerConfig(parsedConfig.server || {}),
        apiKey: parsedConfig.APIKEY || parsedConfig.apiKey || 'default-key',
        version: parsedConfig.version || '4.1',
        description: parsedConfig.description || 'Generated by ConfigPreprocessor',
        lastUpdated: timestamp
      };
      
      return {
        success: true,
        routingTable,
        metadata: {
          configPath,
          processingTime: Date.now() - startTime,
          timestamp,
          sourceFormat: 'v4'
        }
      };
      
    } catch (processingError) {
      return {
        success: false,
        error: {
          code: 'CONFIG_PREPROCESSING_FAILED',
          message: processingError.message,
          details: { configPath }
        },
        metadata: {
          configPath,
          processingTime: Date.now() - startTime,
          timestamp,
          sourceFormat: 'unknown'
        }
      };
    }
  }
  
  private static _readConfigFile(configPath: string): any {
    const fileContent = fs.readFileSync(configPath, 'utf8');
    return JSON.parse(fileContent);
  }
  
  private static _parseConfigContent(config: any): any {
    return {
      providers: config.Providers || config.providers || [],
      router: config.router || {},
      server: config.server || {},
      APIKEY: config.APIKEY || config.apiKey,
      version: config.version,
      description: config.description
    };
  }
  
  private static _expandProviders(providers: any[]): ProviderInfo[] {
    return providers.map(provider => ({
      name: provider.name,
      priority: provider.priority || 1,
      api_base_url: provider.api_base_url || 'http://localhost:1234/v1',
      api_key: provider.api_key || 'default-key',
      models: provider.models || ['default-model'],
      serverCompatibility: provider.serverCompatibility || {
        use: provider.name,
        options: {}
      }
    }));
  }
  
  private static _generateRoutes(routerConfig: any, providers: ProviderInfo[]): RouteMapping {
    const routes: RouteMapping = {};
    
    for (const [routeName, routeValue] of Object.entries(routerConfig)) {
      if (typeof routeValue === 'string') {
        routes[routeName] = routeValue;
      }
    }
    
    if (!routes.default && providers.length > 0) {
      const firstProvider = providers[0];
      const firstModel = firstProvider.models[0];
      routes.default = `${firstProvider.name},${firstModel}`;
    }
    
    return routes;
  }
  
  private static _normalizeServerConfig(serverConfig: any): ServerInfo {
    return {
      port: serverConfig.port || 5506,
      host: serverConfig.host || '0.0.0.0',
      debug: serverConfig.debug || false
    };
  }
}