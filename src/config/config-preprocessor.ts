import * as fs from 'fs';
import { 
  RoutingTable, 
  ProviderInfo, 
  RouteMapping, 
  ServerInfo,
  ConfigPreprocessResult,
  ModelInfo
} from './routing-table-types';

// Export the result type for external use
export { ConfigPreprocessResult } from './routing-table-types';
import { secureLogger } from '../utils/secure-logger';

export class ConfigPreprocessor {
  
  public static preprocess(configPath: string): ConfigPreprocessResult {
    const startTime = Date.now();
    const timestamp = new Date().toISOString();
    
    try {
      const rawConfig = ConfigPreprocessor._readConfigFile(configPath);
      const parsedConfig = ConfigPreprocessor._parseConfigContent(rawConfig);
      const providers = ConfigPreprocessor._expandProviders(parsedConfig.providers || []);
      const routes = ConfigPreprocessor._generateRoutes(parsedConfig.router || {}, providers);
      
      const routingTable: RoutingTable = {
        providers,
        routes,
        server: ConfigPreprocessor._normalizeServerConfig(parsedConfig.server || {}),
        apiKey: parsedConfig.APIKEY || parsedConfig.apiKey || 'default-key',
        version: parsedConfig.version || '4.1',
        description: parsedConfig.description || 'Generated by ConfigPreprocessor',
        lastUpdated: timestamp
      };
      
      return {
        success: true,
        routingTable,
        metadata: {
          configPath,
          processingTime: Date.now() - startTime,
          timestamp,
          sourceFormat: 'v4'
        }
      };
      
    } catch (processingError) {
      return {
        success: false,
        error: {
          code: 'CONFIG_PREPROCESSING_FAILED',
          message: processingError.message,
          details: { configPath }
        },
        metadata: {
          configPath,
          processingTime: Date.now() - startTime,
          timestamp,
          sourceFormat: 'unknown'
        }
      };
    }
  }
  
  private static _readConfigFile(configPath: string): any {
    const fileContent = fs.readFileSync(configPath, 'utf8');
    return JSON.parse(fileContent);
  }
  
  private static _parseConfigContent(config: any): any {
    return {
      providers: config.Providers || config.providers || [],
      router: config.router || {},
      server: config.server || {},
      APIKEY: config.APIKEY || config.apiKey,
      version: config.version,
      description: config.description
    };
  }
  
  private static _expandProviders(providers: any[]): ProviderInfo[] {
    return providers.map(provider => {
      // 处理serverCompatibility配置，但不添加硬编码默认值
      let serverCompatibility = provider.serverCompatibility;
      
      // 如果没有提供serverCompatibility配置，使用最小结构
      if (!serverCompatibility) {
        serverCompatibility = {
          use: provider.name,
          options: {}
        };
      }
      
      // 确保options对象存在
      if (!serverCompatibility.options) {
        serverCompatibility.options = {};
      }
      
      // 处理模型配置，支持字符串和对象格式
      let models: (string | ModelInfo)[] = [];
      if (Array.isArray(provider.models)) {
        models = provider.models.map(model => {
          if (typeof model === 'string') {
            return model;
          } else if (typeof model === 'object' && model.name) {
            return {
              name: model.name,
              maxTokens: model.maxTokens,
              ...model
            };
          }
          return String(model);
        });
      } else {
        models = [`${provider.name}-default-model`];
      }
      
      return {
        name: provider.name,
        priority: provider.priority || 1,
        api_base_url: provider.api_base_url,
        api_key: provider.api_key,
        maxTokens: provider.maxTokens,
        models: models,
        serverCompatibility: serverCompatibility
      };
    });
  }
  
  private static _generateRoutes(routerConfig: any, providers: ProviderInfo[]): RouteMapping {
    const routes: RouteMapping = {};
    
    for (const [routeName, routeValue] of Object.entries(routerConfig)) {
      if (typeof routeValue === 'string') {
        routes[routeName] = routeValue;
      }
    }
    
    if (!routes.default && providers.length > 0) {
      const firstProvider = providers[0];
      const firstModel = firstProvider.models[0];
      routes.default = `${firstProvider.name},${firstModel}`;
    }
    
    return routes;
  }
  
  private static _normalizeServerConfig(serverConfig: any): ServerInfo {
    return {
      port: serverConfig.port || 5506,
      host: serverConfig.host || '0.0.0.0',
      debug: serverConfig.debug || false
    };
  }
}