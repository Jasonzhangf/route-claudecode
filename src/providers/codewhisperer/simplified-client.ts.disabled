/**
 * CodeWhisperer Simplified Client - Transformeræ¶æ„å®ç°
 * çº¯APIè°ƒç”¨å®¢æˆ·ç«¯ï¼Œæ ¼å¼è½¬æ¢ç”±Transformerå¤„ç†ï¼Œä¼šè¯ç®¡ç†ç”±Session Managerå¤„ç†
 * é¡¹ç›®æ‰€æœ‰è€…: Jason Zhang
 */

import { BaseRequest, BaseResponse, Provider, ProviderConfig, ProviderError } from '@/types';
import { logger } from '@/utils/logger';
import { getSimpleSessionManager } from '@/session/simple-session-manager';
import { CodeWhispererAuth } from './auth';
import { EnhancedCodeWhispererClient } from './enhanced-client';
import { AuthMethod } from './enhanced-auth-config';

export interface CodeWhispererSimplifiedConfig extends ProviderConfig {
  // CodeWhispererç‰¹å®šé…ç½®
  region?: string;
  profileArn?: string;
  authMethod?: 'social' | 'builtin';
}

/**
 * CodeWhispererç®€åŒ–å®¢æˆ·ç«¯ - éµå¾ªTransformeræ¶æ„
 * ğŸ¯ èŒè´£åˆ†ç¦»ï¼š
 * - Provider: çº¯APIè°ƒç”¨
 * - Transformer: æ ¼å¼è½¬æ¢
 * - Preprocessor: å…¼å®¹æ€§å¤„ç†
 * - Session Manager: ä¼šè¯ç®¡ç†
 */
export class CodeWhispererSimplifiedClient implements Provider {
  public readonly name: string;
  public readonly type = 'codewhisperer';
  
  protected cwClient: EnhancedCodeWhispererClient;
  public config: CodeWhispererSimplifiedConfig;
  private sessionManager: ReturnType<typeof getSimpleSessionManager>;
  private preprocessor = createCodeWhispererPreprocessor();

  constructor(config: CodeWhispererSimplifiedConfig, providerId: string) {
    this.name = providerId;
    this.config = config;

    // åˆå§‹åŒ–CodeWhispererè®¤è¯å’Œå®¢æˆ·ç«¯
    this.cwClient = this.initializeCodeWhispererClient(config);

    // åˆå§‹åŒ–ä¼šè¯ç®¡ç†
    const port = this.extractPortFromConfig(config);
    this.sessionManager = getSimpleSessionManager(port);

    logger.info('CodeWhisperer Simplified Client initialized with transformer architecture', {
      providerId,
      region: config.region,
      authMethod: config.authMethod,
      hasProfileArn: !!config.profileArn,
      sessionTracking: true,
      transformerEnabled: true,
      preprocessorEnabled: true
    });
  }

  /**
   * åˆå§‹åŒ–CodeWhispererå®¢æˆ·ç«¯
   */
  private initializeCodeWhispererClient(config: CodeWhispererSimplifiedConfig): EnhancedCodeWhispererClient {
    // æ„é€ å…¼å®¹çš„é…ç½®å¯¹è±¡
    const kiroConfig = {
      region: { region: config.region || 'us-east-1' },
      profileArn: config.profileArn,
      authMethod: config.authMethod === 'social' ? AuthMethod.SOCIAL : AuthMethod.IDC
    };
    
    return new EnhancedCodeWhispererClient(kiroConfig);
  }

  /**
   * æå–ç«¯å£é…ç½®
   */
  private extractPortFromConfig(config: CodeWhispererSimplifiedConfig): number {
    if (process.env.RCC_PORT) {
      return parseInt(process.env.RCC_PORT, 10);
    }
    return 3456;
  }

  /**
   * å¥åº·æ£€æŸ¥
   */
  async isHealthy(): Promise<boolean> {
    try {
      const healthResult = await this.cwClient.healthCheck();
      return healthResult.healthy;
    } catch (error) {
      logger.warn('CodeWhisperer health check failed', {
        error: error instanceof Error ? error.message : String(error),
        provider: this.name
      });
      return false;
    }
  }

  /**
   * ğŸš¨ é›¶é™é»˜å¤±è´¥ï¼šå‘é€éæµå¼è¯·æ±‚
   */
  async sendRequest(request: BaseRequest): Promise<BaseResponse> {
    const originalRequestId = request.metadata?.requestId || 'unknown';
    const sessionId = request.metadata?.sessionId;
    const conversationId = request.metadata?.conversationId;

    // ç”Ÿæˆè¯·æ±‚IDå¹¶å¯ç”¨ä¼šè¯è·Ÿè¸ª
    if (sessionId && conversationId && this.sessionManager) {
      const requestId = this.sessionManager.generateRequestId(
        sessionId,
        conversationId,
        false // non-streaming
      );

      request.metadata = {
        ...request.metadata,
        requestId,
        originalRequestId
      };

      logger.debug('Processing non-streaming CodeWhisperer request with session tracking', {
        originalRequestId,
        requestId,
        sessionId,
        conversationId,
        provider: this.name
      }, requestId, 'provider');

      try {
        const response = await this.processNonStreamingRequest(request);
        
        // ğŸš¨ Critical: éªŒè¯å“åº”å®Œæ•´æ€§ - é›¶é™é»˜å¤±è´¥
        this.validateNonStreamingResponse(response, requestId);
        
        this.sessionManager.completeRequest(requestId, response.stop_reason || 'unknown');
        return response;

      } catch (error) {
        // ğŸš¨ Critical: ç¡®ä¿æ— é™é»˜å¤±è´¥ - æ‰€æœ‰é”™è¯¯å¿…é¡»æŠ›å‡º
        console.error(`ğŸš¨ [${this.name}] NON-STREAMING REQUEST FAILED - NO SILENT FAILURE:`);
        console.error(`   Request ID: ${requestId}`);
        console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
        console.error(`   Provider: ${this.name}`);
        console.error(`   RESULT: Throwing error to client`);
        
        this.sessionManager.failRequest(requestId, error);
        throw error;
      }
    } else {
      // æ— ä¼šè¯ä¿¡æ¯çš„è¯·æ±‚å¤„ç†
      try {
        const response = await this.processNonStreamingRequest(request);
        this.validateNonStreamingResponse(response, originalRequestId);
        return response;
      } catch (error) {
        console.error(`ğŸš¨ [${this.name}] NON-STREAMING REQUEST FAILED - NO SILENT FAILURE:`);
        console.error(`   Request ID: ${originalRequestId}`);
        console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
        console.error(`   RESULT: Throwing error to client`);
        throw error;
      }
    }
  }

  /**
   * å¤„ç†éæµå¼è¯·æ±‚çš„å†…éƒ¨é€»è¾‘
   */
  private async processNonStreamingRequest(request: BaseRequest): Promise<BaseResponse> {
    const requestId = request.metadata?.requestId || 'unknown';

    try {
      // Step 1: é¢„å¤„ç† - åº”ç”¨å…¼å®¹æ€§ä¿®å¤
      let processedRequest = this.preprocessor.applyCompatibilityFixes(request);
      
      // Step 2: éªŒè¯è¯·æ±‚å®Œæ•´æ€§
      this.preprocessor.validateRequest(processedRequest);

      // Step 3: è½¬æ¢ä¸ºCodeWhispereræ ¼å¼
      const cwRequest = transformationManager.transformRequest(
        processedRequest, 
        {
          sourceProvider: 'anthropic', // è¾“å…¥æ ¼å¼å‡è®¾ä¸ºAnthropic
          targetProvider: 'codewhisperer'
        },
        requestId
      );

      // Step 4: å‘é€APIè¯·æ±‚
      logger.debug('Sending request to CodeWhisperer API', {
        requestId,
        model: cwRequest.model,
        messageCount: cwRequest.messages.length,
        hasTools: !!(cwRequest.tools && cwRequest.tools.length > 0)
      });

      const cwResponse = await this.cwClient.handleNonStreamRequest(cwRequest);

      // Step 5: è½¬æ¢å“åº”æ ¼å¼
      const unifiedResponse = transformationManager.transformResponse(
        cwResponse,
        {
          sourceProvider: 'codewhisperer',
          targetProvider: 'anthropic' // è¾“å‡ºæ ¼å¼ä¸ºAnthropic
        },
        requestId
      );

      logger.debug('CodeWhisperer non-streaming request completed', {
        requestId,
        responseId: unifiedResponse.id,
        contentBlocks: unifiedResponse.content.length,
        stopReason: unifiedResponse.stop_reason
      });

      return unifiedResponse;

    } catch (error) {
      logger.error('CodeWhisperer non-streaming request failed', {
        error: error instanceof Error ? error.message : String(error),
        provider: this.name,
        requestId
      }, requestId, 'provider');

      // åŒ…è£…ä¸ºProviderErrorä»¥æä¾›æ›´å¤šä¸Šä¸‹æ–‡
      if (error instanceof Error) {
        throw new ProviderError(
          `CodeWhisperer Non-Streaming Error: ${error.message}`,
          this.name,
          500,
          error
        );
      }
      throw error;
    }
  }

  /**
   * ğŸš¨ é›¶é™é»˜å¤±è´¥ï¼šå‘é€æµå¼è¯·æ±‚
   */
  async *sendStreamRequest(request: BaseRequest): AsyncIterable<any> {
    const originalRequestId = request.metadata?.requestId || 'unknown';
    const sessionId = request.metadata?.sessionId;
    const conversationId = request.metadata?.conversationId;

    // ç”Ÿæˆè¯·æ±‚IDå¹¶å¯ç”¨ä¼šè¯è·Ÿè¸ª
    if (sessionId && conversationId && this.sessionManager) {
      const requestId = this.sessionManager.generateRequestId(
        sessionId,
        conversationId,
        true // streaming
      );

      request.metadata = {
        ...request.metadata,
        requestId,
        originalRequestId
      };

      logger.debug('Processing streaming CodeWhisperer request with session tracking', {
        originalRequestId,
        requestId,
        sessionId,
        conversationId,
        provider: this.name
      }, requestId, 'provider');

      let chunkCount = 0;
      let hasValidContent = false;
      let finishReason: string | undefined;
      
      try {
        for await (const chunk of this.processStreamingRequest(request)) {
          chunkCount++;
          
          // ğŸš¨ Critical: éªŒè¯æµå¼chunk - é›¶é™é»˜å¤±è´¥
          this.validateStreamingChunk(chunk, requestId, chunkCount);
          
          // è·Ÿè¸ªæœ‰æ•ˆå†…å®¹
          if (chunk?.event === 'content_block_delta' || 
              chunk?.event === 'content_block_start' ||
              chunk?.event === 'message_start') {
            hasValidContent = true;
          }
          
          // æå–finish reason
          if (chunk?.event === 'message_delta' && chunk?.data?.delta?.stop_reason) {
            finishReason = chunk.data.delta.stop_reason;
          }
          
          yield chunk;
        }
        
        // ğŸš¨ Critical: ç¡®ä¿æµå¼è¯·æ±‚äº§ç”Ÿäº†æœ‰æ•ˆå†…å®¹
        if (chunkCount === 0) {
          const error = new Error('Streaming request produced no chunks - potential silent failure');
          console.error(`ğŸš¨ [${this.name}] STREAMING SILENT FAILURE DETECTED:`);
          console.error(`   Request ID: ${requestId}`);
          console.error(`   Chunks: ${chunkCount}`);
          console.error(`   Valid Content: ${hasValidContent}`);
          console.error(`   RESULT: Throwing error to prevent silent failure`);
          throw error;
        }
        
        this.sessionManager.completeRequest(requestId, finishReason || 'stream_end');
      } catch (error) {
        console.error(`ğŸš¨ [${this.name}] STREAMING REQUEST FAILED - NO SILENT FAILURE:`);
        console.error(`   Request ID: ${requestId}`);
        console.error(`   Chunks Processed: ${chunkCount}`);
        console.error(`   Had Valid Content: ${hasValidContent}`);
        console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
        console.error(`   RESULT: Throwing error to client`);
        
        this.sessionManager.failRequest(requestId, error);
        throw error;
      }
    } else {
      // æ— ä¼šè¯ä¿¡æ¯çš„æµå¼è¯·æ±‚å¤„ç†
      let chunkCount = 0;
      let hasValidContent = false;
      
      try {
        for await (const chunk of this.processStreamingRequest(request)) {
          chunkCount++;
          this.validateStreamingChunk(chunk, originalRequestId, chunkCount);
          
          if (chunk?.event === 'content_block_delta' || 
              chunk?.event === 'content_block_start' ||
              chunk?.event === 'message_start') {
            hasValidContent = true;
          }
          
          yield chunk;
        }
        
        if (chunkCount === 0) {
          const error = new Error('Streaming request produced no chunks - potential silent failure');
          console.error(`ğŸš¨ [${this.name}] STREAMING SILENT FAILURE DETECTED:`);
          console.error(`   Request ID: ${originalRequestId}`);
          console.error(`   Chunks: ${chunkCount}`);
          console.error(`   Valid Content: ${hasValidContent}`);
          throw error;
        }
      } catch (error) {
        console.error(`ğŸš¨ [${this.name}] STREAMING REQUEST FAILED - NO SILENT FAILURE:`);
        console.error(`   Request ID: ${originalRequestId}`);
        console.error(`   Chunks Processed: ${chunkCount}`);
        console.error(`   Had Valid Content: ${hasValidContent}`);
        console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
      }
    }
  }

  /**
   * å¤„ç†æµå¼è¯·æ±‚çš„å†…éƒ¨é€»è¾‘
   */
  private async *processStreamingRequest(request: BaseRequest): AsyncIterable<any> {
    const requestId = request.metadata?.requestId || 'unknown';

    try {
      // Step 1: é¢„å¤„ç†
      let processedRequest = this.preprocessor.applyCompatibilityFixes(request);
      this.preprocessor.validateRequest(processedRequest);

      // Step 2: è½¬æ¢ä¸ºCodeWhispereræ ¼å¼
      const cwRequest = transformationManager.transformRequest(
        processedRequest, 
        {
          sourceProvider: 'anthropic',
          targetProvider: 'codewhisperer'
        },
        requestId
      );

      // Step 3: å¤„ç†æµå¼è¯·æ±‚
      const events: any[] = [];
      
      await this.cwClient.handleStreamRequest(
        cwRequest,
        (event: string, data: any) => {
          events.push({ event, data });
        },
        (message: string, error: Error) => {
          throw new Error(`CodeWhisperer streaming error: ${message}`);
        }
      );

      // Step 4: è½¬æ¢å¹¶yieldäº‹ä»¶
      for (const event of events) {
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ äº‹ä»¶æ ¼å¼è½¬æ¢é€»è¾‘
        yield event;
      }

    } catch (error) {
      logger.error('CodeWhisperer streaming request failed', {
        error: error instanceof Error ? error.message : String(error),
        provider: this.name,
        requestId
      }, requestId, 'provider');

      if (error instanceof Error) {
        throw new ProviderError(
          `CodeWhisperer Streaming Error: ${error.message}`,
          this.name,
          500,
          error
        );
      }
      throw error;
    }
  }

  /**
   * ğŸš¨ Critical: éªŒè¯éæµå¼å“åº”å®Œæ•´æ€§ - é›¶é™é»˜å¤±è´¥
   */
  private validateNonStreamingResponse(response: BaseResponse, requestId: string): void {
    if (!response) {
      const error = new Error('Response is null or undefined - silent failure detected');
      console.error(`ğŸš¨ [${this.name}] SILENT FAILURE: Null response for ${requestId}`);
      throw error;
    }

    if (!response.content || response.content.length === 0) {
      const error = new Error('Response has no content - potential silent failure');
      console.error(`ğŸš¨ [${this.name}] SILENT FAILURE: Empty content for ${requestId}`);
      throw error;
    }

    if (!response.stop_reason) {
      const error = new Error('Response missing stop_reason - potential silent failure');
      console.error(`ğŸš¨ [${this.name}] SILENT FAILURE: Missing stop_reason for ${requestId}`);
      throw error;
    }

    // ğŸš¨ é›¶FallbackåŸåˆ™ï¼šæ£€æŸ¥fallbackå€¼
    if (response.stop_reason === 'unknown' || response.stop_reason === 'default') {
      const error = new Error(`Response has fallback stop_reason: ${response.stop_reason} - violates zero fallback principle`);
      console.error(`ğŸš¨ [${this.name}] FALLBACK VIOLATION: ${response.stop_reason} for ${requestId}`);
      throw error;
    }

    logger.debug('Non-streaming response validation passed', {
      requestId,
      contentLength: response.content.length,
      stopReason: response.stop_reason
    });
  }

  /**
   * ğŸš¨ Critical: éªŒè¯æµå¼chunk - é›¶é™é»˜å¤±è´¥
   */
  private validateStreamingChunk(chunk: any, requestId: string, chunkIndex: number): void {
    if (!chunk) {
      const error = new Error(`Streaming chunk ${chunkIndex} is null/undefined - silent failure detected`);
      console.error(`ğŸš¨ [${this.name}] STREAMING SILENT FAILURE: Null chunk ${chunkIndex} for ${requestId}`);
      throw error;
    }

    if (!chunk.event) {
      const error = new Error(`Streaming chunk ${chunkIndex} missing event type - malformed chunk`);
      console.error(`ğŸš¨ [${this.name}] STREAMING MALFORMED: Missing event in chunk ${chunkIndex} for ${requestId}`);
      throw error;
    }

    // ğŸš¨ é›¶FallbackåŸåˆ™ï¼šæ£€æŸ¥fallbackäº‹ä»¶ç±»å‹
    if (chunk.event === 'unknown' || chunk.event === 'default' || chunk.event === 'fallback') {
      const error = new Error(`Streaming chunk has fallback event: ${chunk.event} - violates zero fallback principle`);
      console.error(`ğŸš¨ [${this.name}] STREAMING FALLBACK VIOLATION: ${chunk.event} in chunk ${chunkIndex} for ${requestId}`);
      throw error;
    }

    // éªŒè¯chunkæ•°æ®ç»“æ„
    if (chunk.event !== 'ping' && !chunk.data) {
      const error = new Error(`Streaming chunk ${chunkIndex} missing data - malformed chunk`);
      console.error(`ğŸš¨ [${this.name}] STREAMING MALFORMED: Missing data in chunk ${chunkIndex} for ${requestId}`);
      throw error;
    }

    logger.trace(requestId, 'validation', 'Streaming chunk validation passed', {
      chunkIndex,
      event: chunk.event,
      hasData: !!chunk.data
    });
  }
}

/**
 * åˆ›å»ºCodeWhispererç®€åŒ–å®¢æˆ·ç«¯
 */
export function createCodeWhispererSimplifiedClient(
  config: CodeWhispererSimplifiedConfig, 
  providerId: string
): CodeWhispererSimplifiedClient {
  return new CodeWhispererSimplifiedClient(config, providerId);
}