/**
 * Integration tests for CodeWhisperer pipeline
 * Tests complete request flow from input processing to provider response
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach, jest } from '@jest/globals';
import { RouterServer } from '../../src/server';
import { RouterConfig } from '../../src/types';
import axios from 'axios';
import fs from 'fs';
import path from 'path';

// Test configuration
const TEST_PORT = 3457;
const TEST_CONFIG: RouterConfig = {
  server: {
    port: TEST_PORT,
    host: '127.0.0.1'
  },
  routing: {
    defaultProvider: 'test-codewhisperer',
    rules: [
      {
        category: 'default',
        provider: 'test-codewhisperer',
        model: 'claude-sonnet-4-20250514',
        priority: 1
      }
    ],
    providers: {
      'test-codewhisperer': {
        type: 'codewhisperer',
        endpoint: 'https://codewhisperer.us-east-1.amazonaws.com',
        authentication: {
          type: 'bearer',
          credentials: {
            tokenPath: '~/.aws/sso/cache/test-token.json',
            profileArn: 'arn:aws:codewhisperer:us-east-1:699475941385:profile/test'
          }
        },
        settings: {
          maxConcurrentRequests: 5,
          timeoutMs: 30000
        }
      }
    }
  },
  debug: {
    enabled: true,
    logLevel: 'debug',
    traceRequests: true,
    saveRequests: true,
    logDir: '/tmp/ccr-integration-test-logs'
  },
  hooks: []
};

describe('CodeWhisperer Pipeline Integration', () => {
  let server: RouterServer;
  let baseURL: string;

  beforeAll(async () => {
    // Create mock token file
    const mockToken = {
      accessToken: 'integration-test-token',
      expiresAt: new Date(Date.now() + 3600000).toISOString(),
      region: 'us-east-1'
    };

    // Mock fs operations
    jest.spyOn(fs, 'readFileSync').mockReturnValue(JSON.stringify(mockToken));
    jest.spyOn(fs, 'existsSync').mockReturnValue(true);

    // Initialize server
    server = new RouterServer(TEST_CONFIG);
    baseURL = `http://127.0.0.1:${TEST_PORT}`;

    // Start server
    await server.start();
    
    // Wait for server to be ready
    await new Promise(resolve => setTimeout(resolve, 2000));
  });

  afterAll(async () => {
    if (server) {
      await server.stop();
    }
    jest.restoreAllMocks();
  });

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Health and Status Endpoints', () => {
    it('should respond to health check', async () => {
      const response = await axios.get(`${baseURL}/health`);
      
      expect(response.status).toBe(200);
      expect(response.data).toHaveProperty('overall');
      expect(response.data).toHaveProperty('providers');
      expect(response.data.providers['test-codewhisperer']).toBeDefined();
    });

    it('should respond to status check', async () => {
      const response = await axios.get(`${baseURL}/status`);
      
      expect(response.status).toBe(200);
      expect(response.data).toHaveProperty('server', 'claude-code-router');
      expect(response.data).toHaveProperty('version', '2.0.0');
      expect(response.data).toHaveProperty('providers');
      expect(response.data.providers).toContain('test-codewhisperer');
    });
  });

  describe('Request Processing Pipeline', () => {
    beforeEach(() => {
      // Mock CodeWhisperer API response
      const mockCWResponse = {
        output: {
          message: {
            role: 'assistant',
            content: [
              { text: 'Hello! This is a test response from CodeWhisperer.' }
            ]
          }
        },
        usage: {
          inputTokens: 15,
          outputTokens: 25,
          totalTokens: 40
        },
        responseMetadata: {
          requestId: 'cw-mock-123'
        }
      };

      // Mock axios for CodeWhisperer API calls
      jest.spyOn(axios, 'post').mockResolvedValue({
        data: mockCWResponse,
        status: 200,
        statusText: 'OK',
        headers: {},
        config: {}
      });
    });

    it('should process simple message request', async () => {
      const request = {
        model: 'claude-sonnet-4-20250514',
        max_tokens: 100,
        messages: [
          {
            role: 'user',
            content: 'Hello, this is a test message.'
          }
        ]
      };

      const response = await axios.post(`${baseURL}/v1/messages`, request, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-key'
        }
      });

      expect(response.status).toBe(200);
      expect(response.data).toHaveProperty('id');
      expect(response.data).toHaveProperty('type', 'message');
      expect(response.data).toHaveProperty('role', 'assistant');
      expect(response.data).toHaveProperty('content');
      expect(response.data.content[0]).toHaveProperty('type', 'text');
      expect(response.data.content[0].text).toContain('test response');
    });

    it('should handle system messages', async () => {
      const request = {
        model: 'claude-sonnet-4-20250514',
        max_tokens: 100,
        system: 'You are a helpful coding assistant.',
        messages: [
          {
            role: 'user',
            content: 'Help me write a Python function.'
          }
        ]
      };

      const response = await axios.post(`${baseURL}/v1/messages`, request, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-key'
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.role).toBe('assistant');
      
      // Verify that CodeWhisperer API was called with converted request
      expect(axios.post).toHaveBeenCalledWith(
        expect.stringContaining('codewhisperer'),
        expect.objectContaining({
          messages: expect.arrayContaining([
            expect.objectContaining({
              content: expect.arrayContaining([
                expect.objectContaining({
                  text: expect.stringContaining('You are a helpful coding assistant')
                })
              ])
            })
          ])
        }),
        expect.objectContaining({
          headers: expect.objectContaining({
            'Authorization': 'Bearer integration-test-token'
          })
        })
      );
    });

    it('should handle tool use requests', async () => {
      const request = {
        model: 'claude-sonnet-4-20250514',
        max_tokens: 200,
        messages: [
          {
            role: 'user',
            content: 'What is the weather like in New York?'
          }
        ],
        tools: [
          {
            name: 'get_weather',
            description: 'Get current weather information',
            input_schema: {
              type: 'object',
              properties: {
                location: {
                  type: 'string',
                  description: 'The city name'
                }
              },
              required: ['location']
            }
          }
        ]
      };

      // Mock tool use response
      const mockToolResponse = {
        output: {
          message: {
            role: 'assistant',
            content: [
              { text: 'I will check the weather for you.' },
              {
                toolUse: {
                  toolUseId: 'tool-123',
                  name: 'get_weather',
                  input: { location: 'New York' }
                }
              }
            ]
          }
        },
        usage: {
          inputTokens: 20,
          outputTokens: 30,
          totalTokens: 50
        }
      };

      jest.spyOn(axios, 'post').mockResolvedValue({
        data: mockToolResponse,
        status: 200,
        statusText: 'OK',
        headers: {},
        config: {}
      });

      const response = await axios.post(`${baseURL}/v1/messages`, request, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-key'
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.content).toHaveLength(2);
      expect(response.data.content[1]).toHaveProperty('type', 'tool_use');
      expect(response.data.content[1]).toHaveProperty('name', 'get_weather');
    });

    it('should handle different routing categories', async () => {
      const testCases = [
        { category: 'default', expectedProvider: 'test-codewhisperer' },
        { category: 'code-generation', expectedProvider: 'test-codewhisperer' },
        { category: 'background', expectedProvider: 'test-codewhisperer' }
      ];

      for (const testCase of testCases) {
        const request = {
          model: 'claude-sonnet-4-20250514',
          max_tokens: 50,
          messages: [
            {
              role: 'user',
              content: `This is a ${testCase.category} request.`
            }
          ]
        };

        const response = await axios.post(`${baseURL}/v1/messages`, request, {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer test-key'
          }
        });

        expect(response.status).toBe(200);
        expect(response.data.role).toBe('assistant');
      }
    });
  });

  describe('Streaming Support', () => {
    it('should handle streaming requests', async () => {
      // Mock streaming response
      const mockStreamEvents = [
        { event: 'message_start', data: { type: 'message_start', message: { id: 'msg_123', type: 'message' } } },
        { event: 'content_block_start', data: { type: 'content_block_start', index: 0, content_block: { type: 'text', text: '' } } },
        { event: 'content_block_delta', data: { type: 'content_block_delta', index: 0, delta: { type: 'text_delta', text: 'Hello' } } },
        { event: 'content_block_delta', data: { type: 'content_block_delta', index: 0, delta: { type: 'text_delta', text: ' world!' } } },
        { event: 'content_block_stop', data: { type: 'content_block_stop', index: 0 } },
        { event: 'message_stop', data: { type: 'message_stop' } }
      ];

      const request = {
        model: 'claude-sonnet-4-20250514',
        max_tokens: 50,
        stream: true,
        messages: [
          {
            role: 'user',
            content: 'Say hello'
          }
        ]
      };

      const response = await axios.post(`${baseURL}/v1/messages`, request, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-key'
        },
        responseType: 'stream',
        timeout: 10000
      });

      expect(response.status).toBe(200);
      expect(response.headers['content-type']).toBe('text/event-stream');

      // For streaming tests, we would need to parse the SSE stream
      // This is a simplified check
      expect(response.data).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid request format', async () => {
      const invalidRequest = {
        // Missing required fields
        messages: []
      };

      try {
        await axios.post(`${baseURL}/v1/messages`, invalidRequest, {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer test-key'
          }
        });
        fail('Should have thrown an error');
      } catch (error) {
        expect(error.response.status).toBe(400);
        expect(error.response.data).toHaveProperty('error');
      }
    });

    it('should handle provider errors', async () => {
      // Mock CodeWhisperer API error
      jest.spyOn(axios, 'post').mockRejectedValue({
        response: {
          status: 429,
          data: {
            error: {
              message: 'Rate limit exceeded',
              code: 'ThrottlingException'
            }
          }
        }
      });

      const request = {
        model: 'claude-sonnet-4-20250514',
        max_tokens: 50,
        messages: [
          {
            role: 'user',
            content: 'This should fail'
          }
        ]
      };

      try {
        await axios.post(`${baseURL}/v1/messages`, request, {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer test-key'
          }
        });
        fail('Should have thrown an error');
      } catch (error) {
        expect(error.response.status).toBe(500);
        expect(error.response.data).toHaveProperty('error');
      }
    });

    it('should handle network timeouts', async () => {
      // Mock network timeout
      jest.spyOn(axios, 'post').mockRejectedValue(new Error('Network timeout'));

      const request = {
        model: 'claude-sonnet-4-20250514',
        max_tokens: 50,
        messages: [
          {
            role: 'user',
            content: 'This should timeout'
          }
        ]
      };

      try {
        await axios.post(`${baseURL}/v1/messages`, request, {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer test-key'
          }
        });
        fail('Should have thrown an error');
      } catch (error) {
        expect(error.response.status).toBe(500);
        expect(error.response.data.error.message).toContain('timeout');
      }
    });
  });

  describe('Request Tracing and Debugging', () => {
    it('should trace requests when debug mode is enabled', async () => {
      const request = {
        model: 'claude-sonnet-4-20250514',
        max_tokens: 50,
        messages: [
          {
            role: 'user',
            content: 'Trace this request'
          }
        ]
      };

      const response = await axios.post(`${baseURL}/v1/messages`, request, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-key'
        }
      });

      expect(response.status).toBe(200);
      
      // In a real implementation, we would check log files or trace data
      // For now, we just verify the request completed successfully
      expect(response.data.role).toBe('assistant');
    });
  });
});

describe('End-to-End Workflow Tests', () => {
  let server: RouterServer;

  beforeEach(async () => {
    // Mock token
    const mockToken = {
      accessToken: 'e2e-test-token',
      expiresAt: new Date(Date.now() + 3600000).toISOString(),
      region: 'us-east-1'
    };

    jest.spyOn(fs, 'readFileSync').mockReturnValue(JSON.stringify(mockToken));
    jest.spyOn(fs, 'existsSync').mockReturnValue(true);

    server = new RouterServer(TEST_CONFIG);
    await server.start();
  });

  afterEach(async () => {
    if (server) {
      await server.stop();
    }
    jest.restoreAllMocks();
  });

  it('should complete a full conversation workflow', async () => {
    const baseURL = `http://127.0.0.1:${TEST_PORT}`;

    // Mock successful responses for each request
    const mockResponses = [
      {
        output: {
          message: {
            role: 'assistant',
            content: [{ text: 'Hello! How can I help you with coding today?' }]
          }
        },
        usage: { inputTokens: 10, outputTokens: 15, totalTokens: 25 }
      },
      {
        output: {
          message: {
            role: 'assistant',
            content: [{ text: 'Here is a simple Python function:\n\n```python\ndef add_numbers(a, b):\n    return a + b\n```' }]
          }
        },
        usage: { inputTokens: 20, outputTokens: 30, totalTokens: 50 }
      }
    ];

    jest.spyOn(axios, 'post')
      .mockResolvedValueOnce({ data: mockResponses[0], status: 200 })
      .mockResolvedValueOnce({ data: mockResponses[1], status: 200 });

    // First request - greeting
    const greetingRequest = {
      model: 'claude-sonnet-4-20250514',
      max_tokens: 100,
      messages: [
        { role: 'user', content: 'Hello! I need help with Python programming.' }
      ]
    };

    const greetingResponse = await axios.post(`${baseURL}/v1/messages`, greetingRequest, {
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer test-key' }
    });

    expect(greetingResponse.status).toBe(200);
    expect(greetingResponse.data.content[0].text).toContain('help you with coding');

    // Second request - code generation
    const codeRequest = {
      model: 'claude-sonnet-4-20250514',
      max_tokens: 200,
      messages: [
        { role: 'user', content: 'Hello! I need help with Python programming.' },
        { role: 'assistant', content: greetingResponse.data.content[0].text },
        { role: 'user', content: 'Please write a function to add two numbers.' }
      ]
    };

    const codeResponse = await axios.post(`${baseURL}/v1/messages`, codeRequest, {
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer test-key' }
    });

    expect(codeResponse.status).toBe(200);
    expect(codeResponse.data.content[0].text).toContain('def add_numbers');
    expect(codeResponse.data.content[0].text).toContain('return a + b');

    // Verify both requests were routed to CodeWhisperer
    expect(axios.post).toHaveBeenCalledTimes(2);
    expect(axios.post).toHaveBeenCalledWith(
      expect.stringContaining('codewhisperer'),
      expect.objectContaining({ model: 'CLAUDE_SONNET_4_20250514_V1_0' }),
      expect.any(Object)
    );
  });
});