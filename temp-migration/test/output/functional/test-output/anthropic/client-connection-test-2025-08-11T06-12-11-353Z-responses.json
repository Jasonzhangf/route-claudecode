[
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.338Z",
    "data": {
      "rawLine": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": null,
        "message": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
        "stack": null
      },
      "performance": null
    },
    "metadata": {
      "lineNumber": 1641,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.338Z",
      "dataSize": 2676
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T02:49:19.230Z",
    "data": {
      "rawLine": "[2025-08-11T02:49:19.230Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
      "timestamp": "2025-08-11T02:49:19.230Z",
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "debug",
        "message": "[2025-08-11T02:49:19.230Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 1642,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.339Z",
      "dataSize": 4495
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.339Z",
    "data": {
      "rawLine": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": 123,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "error",
        "message": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 1864,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.339Z",
      "dataSize": 1727
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.340Z",
    "data": {
      "rawLine": "        \"description\": \"\\n- Allows Claude to search the web and use the results to inform responses\\n- Provides up-to-date information for current events and recent data\\n- Returns search result information formatted as search result blocks\\n- Use this tool for accessing information beyond Claude's knowledge cutoff\\n- Searches are performed automatically within a single API call\\n\\nUsage notes:\\n  - Domain filtering is supported to include or block specific websites\\n  - Web search is only available in the US\\n  - Account for \\\"Today's date\\\" in <env>. For example, if <env> says \\\"Today's date: 2025-07-01\\\", and the user wants the latest docs, do not use 2024 in the search query. Use 2025.\\n\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": null,
      "performance": null
    },
    "metadata": {
      "lineNumber": 2163,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.340Z",
      "dataSize": 702
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T02:49:22.346Z",
    "data": {
      "rawLine": "[2025-08-11T02:49:22.346Z] SERVER-OUT: [10:49:22] [DEBUG] [system] [eafd3a0a-2e1f-426c-94bf-d02e0207a80e] [response-converter] Converted OpenAI response to Anthropic format",
      "timestamp": "2025-08-11T02:49:22.346Z",
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": null,
      "performance": null
    },
    "metadata": {
      "lineNumber": 3127,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.341Z",
      "dataSize": 172
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T02:49:26.404Z",
    "data": {
      "rawLine": "[2025-08-11T02:49:26.404Z] SERVER-OUT: [10:49:26] [DEBUG] [system] Selected processor: anthropic",
      "timestamp": "2025-08-11T02:49:26.404Z",
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "debug",
        "message": "[2025-08-11T02:49:26.404Z] SERVER-OUT: [10:49:26] [DEBUG] [system] Selected processor: anthropic",
        "stack": null
      },
      "performance": null
    },
    "metadata": {
      "lineNumber": 3364,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.341Z",
      "dataSize": 96
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.343Z",
    "data": {
      "rawLine": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": null,
        "message": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
        "stack": null
      },
      "performance": null
    },
    "metadata": {
      "lineNumber": 4422,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.343Z",
      "dataSize": 2676
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T02:49:26.527Z",
    "data": {
      "rawLine": "[2025-08-11T02:49:26.527Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
      "timestamp": "2025-08-11T02:49:26.527Z",
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "debug",
        "message": "[2025-08-11T02:49:26.527Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 4423,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.343Z",
      "dataSize": 4495
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.344Z",
    "data": {
      "rawLine": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": 123,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "error",
        "message": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 4645,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.344Z",
      "dataSize": 1727
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.344Z",
    "data": {
      "rawLine": "        \"description\": \"\\n- Allows Claude to search the web and use the results to inform responses\\n- Provides up-to-date information for current events and recent data\\n- Returns search result information formatted as search result blocks\\n- Use this tool for accessing information beyond Claude's knowledge cutoff\\n- Searches are performed automatically within a single API call\\n\\nUsage notes:\\n  - Domain filtering is supported to include or block specific websites\\n  - Web search is only available in the US\\n  - Account for \\\"Today's date\\\" in <env>. For example, if <env> says \\\"Today's date: 2025-07-01\\\", and the user wants the latest docs, do not use 2024 in the search query. Use 2025.\\n\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": null,
      "performance": null
    },
    "metadata": {
      "lineNumber": 4944,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.344Z",
      "dataSize": 702
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.346Z",
    "data": {
      "rawLine": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": null,
        "message": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
        "stack": null
      },
      "performance": null
    },
    "metadata": {
      "lineNumber": 6185,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.346Z",
      "dataSize": 2676
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T02:49:31.422Z",
    "data": {
      "rawLine": "[2025-08-11T02:49:31.422Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
      "timestamp": "2025-08-11T02:49:31.422Z",
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "debug",
        "message": "[2025-08-11T02:49:31.422Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 6186,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.346Z",
      "dataSize": 4495
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.347Z",
    "data": {
      "rawLine": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": 123,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "error",
        "message": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 6408,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.347Z",
      "dataSize": 1727
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.348Z",
    "data": {
      "rawLine": "        \"description\": \"\\n- Allows Claude to search the web and use the results to inform responses\\n- Provides up-to-date information for current events and recent data\\n- Returns search result information formatted as search result blocks\\n- Use this tool for accessing information beyond Claude's knowledge cutoff\\n- Searches are performed automatically within a single API call\\n\\nUsage notes:\\n  - Domain filtering is supported to include or block specific websites\\n  - Web search is only available in the US\\n  - Account for \\\"Today's date\\\" in <env>. For example, if <env> says \\\"Today's date: 2025-07-01\\\", and the user wants the latest docs, do not use 2024 in the search query. Use 2025.\\n\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": null,
      "performance": null
    },
    "metadata": {
      "lineNumber": 6707,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.348Z",
      "dataSize": 702
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.349Z",
    "data": {
      "rawLine": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": null,
        "message": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
        "stack": null
      },
      "performance": null
    },
    "metadata": {
      "lineNumber": 7518,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.349Z",
      "dataSize": 2676
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T02:49:35.640Z",
    "data": {
      "rawLine": "[2025-08-11T02:49:35.640Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
      "timestamp": "2025-08-11T02:49:35.640Z",
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "debug",
        "message": "[2025-08-11T02:49:35.640Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 7519,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.349Z",
      "dataSize": 4495
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.350Z",
    "data": {
      "rawLine": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": 123,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "error",
        "message": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 7741,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.350Z",
      "dataSize": 1727
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.350Z",
    "data": {
      "rawLine": "        \"description\": \"\\n- Allows Claude to search the web and use the results to inform responses\\n- Provides up-to-date information for current events and recent data\\n- Returns search result information formatted as search result blocks\\n- Use this tool for accessing information beyond Claude's knowledge cutoff\\n- Searches are performed automatically within a single API call\\n\\nUsage notes:\\n  - Domain filtering is supported to include or block specific websites\\n  - Web search is only available in the US\\n  - Account for \\\"Today's date\\\" in <env>. For example, if <env> says \\\"Today's date: 2025-07-01\\\", and the user wants the latest docs, do not use 2024 in the search query. Use 2025.\\n\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": null,
      "performance": null
    },
    "metadata": {
      "lineNumber": 8040,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.350Z",
      "dataSize": 702
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.351Z",
    "data": {
      "rawLine": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": null,
        "message": "      \"content\": \"<system-reminder>\\nAs you answer the user's questions, you can use the following context:\\n# claudeMd\\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\\n\\nContents of /Users/fanzhang/.claude/CLAUDE.md (user's private global instructions for all projects):\\n\\n- 请以后运行终端命令时使用&，让命令可以后台无阻塞执行\\n\\n# 虚拟环境管理规则\\n- 虚拟环境路径统一为项目根目录下的 `./venv`\\n- 运行任何命令前，必须先激活虚拟环境：`source ./venv/bin/activate`\\n- 创建虚拟环境的命令：`python3 -m venv ./venv`\\n- 在虚拟环境中运行所有开发、测试和部署命令\\n- 每次运行`npm`, `yarn`, `pip`等包管理命令前，确保虚拟环境已激活\\n\\n# Claude Code Router Enhanced 统一脚本规范\\n## 服务端口配置  \\n- **Claude Code Router**: `3456` (主要API端点)\\n- **日志监控**: `/tmp/ccr-dev.log`\\n## 项目启动规范\\n- **统一使用**: `./fix-and-test.sh` 进行开发调试\\n- **服务监控**: `tail -f /tmp/ccr-dev.log`\\n- **状态检查**: `node dist/cli.js status`\\n\\n\\n\\n\\n\\n\\n\\n\\n# 所有项目启动脚本\\n- **完整开发流程**: `./fix-and-test.sh` (构建+启动+测试一体化)\\n- **开发模式启动**: `./start-dev.sh` (自动构建+启动服务+日志记录)\\n- **单独构建**: `./build.sh` (清理和构建项目)\\n- **测试套件**: `./test-all.sh` (完整测试，包括API和transformer验证)\\n- **本地安装**: `./install-local.sh` (构建+打包+全局安装)\\n- **启动脚本端口管理**: 自动监控本地项目前后端服务器端口，遇到冲突直接关闭并继续启动，无需人工确认\\n- **本地启动脚本处理**: 如果存在其他本地启动脚本，需要重命名并更新相关配置\\n\\n# 最高优先级编码规则\\n- 不允许硬编码\\n- 不允许使用fallback机制\\n\\n# 安全配置规则\\n- 不允许覆盖~/.gemini/.env\\n\\n# 构建规则\\n- **完整构建必须成功**: 不使用fallback机制，不手动操作\\n- **依赖解析**: 必须解决所有外部依赖和workspace包依赖\\n- **Clean安装验证**: 每次构建后必须验证clean环境下的npm全局安装成功\\n- **esbuild配置**: 包含完整的external依赖列表和workspace解析\\n- **构建流程**: 1)修复依赖 2)完整构建 3)npm pack测试 4)clean安装验证\\n\\n# 编程规范：细菌式编程\\n- 小巧（Small）：在生物世界里，复制和维护每一行\\\"代码\\\"（DNA碱基对）都需要消耗能量。因此，自然选择的压力使得细菌的基因组非常精简，杜绝任何不必要的膨胀\\n- 模块化（Modular）：细菌的基因（功能）被组织成可插拔的\\\"操纵子\\\"（Operon，功能相关的基因簇）。这种模块化的设计使得不同的功能单元可以被轻松地组合或替换\\n- 自包含（Self-contained）：细菌通过\\\"水平基因转移\\\"（Horizontal Gene Transfer）的方式，可以直接\\\"复制粘贴\\\"有用的基因片段，而无需理解对方整个基因组的上下文。这种能力是它们快速适应环境的关键\\n\\n# 项目所有权\\n- 新文件的项目声明所有者是Jason Zhang\\n\\n# 前度UI设计规范\\n- 所有的UI都是按照卡片排版，默认元素充满95%卡片，所有元素对称且居中对齐\\n- 卡片父级容器要确保子卡片的元素不会超出父卡片的边框范围\\n\\n# 调试规则（全局适用）\\n## 🧪 调试前置检查\\n1. **先检查项目CLAUDE.md和./test目录下的调试进度md文件**：每次调试前必须先查看项目中的调试规则和已知问题\\n2. **查看相关测试记录**：检查项目`test/`目录下相关问题的调试历史记录\\n\\n## 🧪 测试管理系统规范（全局最新版）\\n\\n### 核心测试规则（四大原则）\\n1. **测试一定使用脚本**：所有测试必须通过脚本执行，禁止手动测试\\n2. **用一句话总结测试用例**：每个测试文件名必须能清楚表达测试目的，用其命名测试文件\\n3. **同名MD文档**：每个测试文件(.js)都有对应的同名文档(.md)，每次测试总结更新该MD\\n4. **先查看现有测试**：每次发现问题要测试，先去test文件夹查看是否已经有类似文件\\n\\n### 测试文件组织结构\\n```\\ntest/\\n├── functional/     # 功能测试 (工具调用、多轮对话等)\\n├── integration/    # 集成测试 (端到端、供应商集成)\\n├── pipeline/       # 流水线测试 (6步骤标准流程)\\n├── performance/    # 性能测试 (调试、解析性能)\\n└── docs/          # 测试文档总结\\n```\\n\\n### 测试命名规范\\n- **测试文件**：`test-[一句话描述].js`\\n- **文档文件**：`test-[一句话描述].md`\\",
        "stack": null
      },
      "performance": null
    },
    "metadata": {
      "lineNumber": 8646,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.351Z",
      "dataSize": 2676
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T02:49:41.658Z",
    "data": {
      "rawLine": "[2025-08-11T02:49:41.658Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
      "timestamp": "2025-08-11T02:49:41.658Z",
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "debug",
        "message": "[2025-08-11T02:49:41.658Z] SERVER-OUT: n- **日志文件**：`/tmp/test-[测试名]-[时间戳].log`\\n\\n### 测试脚本统一工具\\n- **统一运行器**：`./test-runner.sh`\\n- **列出所有测试**：`./test-runner.sh --list`\\n- **搜索相关测试**：`./test-runner.sh --search <关键词>`\\n- **按分类运行**：`./test-runner.sh --category <分类>`\\n- **运行单个测试**：`./test-runner.sh <测试文件路径>`\\n\\n### 测试文档规范\\n每个MD文档必须包含：\\n- **测试用例**：用一句话描述测试目的\\n- **测试目标**：具体要验证什么问题\\n- **最近执行记录**：时间、状态、执行时长、日志文件\\n- **历史执行记录**：保留多次执行历史\\n- **相关文件**：测试脚本和日志文件路径\\n\\n### 测试文件组织规则（更新版）\\n1. **统一目录**：所有测试脚本放在项目根目录的`test/`文件夹下，按功能分类到子目录\\n2. **功能分类**：按调试功能区分脚本命名和目录组织\\n3. **禁止重复**：如已有相似功能测试脚本，必须修改现有脚本，不允许创建新脚本\\n4. **实时记录**：每次测试不论失败还是成功，都更新对应的MD文档\\n\\n## 分离式调试原则\\n1. **流水线分段**：对于长流水线问题，建立不同阶段的独立测试脚本\\n2. **问题定位**：明确每个测试脚本的作用范围和预期结果\\n3. **阶段验证**：确定问题出现在哪个具体阶段\\n4. **脚本映射**：明确应该使用哪个测试脚本来验证特定问题\\n\\n## 测试脚本命名规范\\n- `test-step[N]-[功能描述].js` - 流水线分段测试\\n- `test-[组件名]-[功能].js` - 组件功能测试  \\n- `debug-[问题域].js` - 问题诊断脚本\\n\\n## 调试记录规范\\n- **文件命名**：`test-[问题关键字]-[YYYYMMDD]-[HHMM].md`\\n- **必含内容**：问题描述、测试方法、发现结果、解决方案\\n- **更新机制**：遇到相关问题时必须先阅读相关记录文件\\n\\n# 发布与提交规则\\n- **前置检查**: 每次`git push`或`npm publish`之前，必须执行以下检查：\\n  1. **构建检查**: 运行 `./build.sh` 确保项目能成功构建。\\n  2. **测试检查**: 如果构建成功，必须运行 `./test-runner.sh` (或相关测试脚本) 确保所有核心测试通过。\\n  3. **确认流程**: 只有在构建和测试都成功后，才能向用户请求批准发布或提交。\\n- npm和github提交必须要用户确认才可以，禁止自己主动发布\\n\\n# 命令执行规则\\n- 频繁调用的命令请构建脚本，不用等待用户每次批准\\n- 一条命令在一个对话里面被调用三次以上就请写成脚本，每次调用这个脚本。脚本的命名要显而易见。\\n\\n# 项目目录\\n- github项目的根目录是~/Documents/github，所有需要克隆到本地的项目都在这里创建\\n\\n\\nContents of /Users/fanzhang/Documents/github/claude-code-router/CLAUDE.md (project instructions, checked into the codebase):\\n\\n# 🎯 Claude Code Router - 项目规则总览\\n\\n## 🚨 MANDATORY COMPLIANCE - 强制执行规则 (NON-NEGOTIABLE)\\n\\n⚠️ **AI模型强制执行指令**: \\n- **MUST READ RULES FIRST**: 每次回应前必须先查阅相关规则文件\\n- **MUST VALIDATE AGAINST RULES**: 每个代码更改必须通过规则验证\\n- **MUST REFERENCE DOCUMENTATION**: 必须引用具体的规则文件和章节\\n- **NO EXCEPTIONS ALLOWED**: 不允许任何例外情况\\n\\n### ❌ 绝对禁令 - 违反即拒绝执行 (ABSOLUTE PROHIBITIONS)\\n\\n#### 🚫 核心技术禁令 (CORE TECHNICAL PROHIBITIONS)\\n- **NO HARDCODING** - 立即拒绝任何硬编码\\n- **NO FALLBACK MECHANISMS** - 禁止任何降级机制\\n- **NO CROSS-NODE COUPLING** - 禁止跨流水线节点耦合\\n- **NO INCOMPLETE DELIVERY REPORTS** - 禁止不完整交付报告\\n\\n#### 🚫 流程管控禁令 (PROCESS CONTROL PROHIBITIONS)\\n- **NO AUTO-PUBLISHING** - 禁止自主发布\\n- **NO SIMULATED E2E TESTS** - 禁止端到端测试模拟\\n- **NO BYPASS SHORTCUTS** - 禁止绕过关键环节\\n- **NO RULE VIOLATIONS** - 禁止违反任何规则\\n\\n#### 🚫 测试执行禁令 (TEST EXECUTION PROHIBITIONS)  \\n- **NO MOCK E2E TESTS** - 端到端测试必须真实连接\\n- **NO SIMULATED CONNECTIONS** - 必须使用 `rcc code --port` 真实连接\\n- **NO E2E SHORTCUTS** - 不可简化或绕过端到端测试环节\\n- **NO FAKE PROVIDER RESPONSES** - Provider连接测试不可使用模拟响应\\n- **NO MOCK INTERNAL PIPELINE** - 客户端连接测试不可Mock内部流水线组件\\n\\n### 🔒 强制执行优先级 (ENFORCEMENT PRIORITIES)\\n1. **P0 - 立即拒绝**: 硬编码、Fallback、自主发布、**流水线跨节点耦合**、**不完整交付报告**、**模拟端到端测试**\\n2. **P1 - 强制查阅**: 架构违反、测试跳过、文档缺失、记忆缺失\\n3. **P2 - 警告纠正**: 命名不规范、注释缺失、性能问题\\n\\n### 🚨 流水线跨节点耦合约束 - P0级强制约束 (PIPELINE CROSS-NODE COUPLING CONSTRAINT)\\n\\n⚠️ **最高优先级架构约束 - 违反将立即无条件修改**\\n\\n#### 🔒 绝对禁令\\n**不可以在流水线上跨节点耦合** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制检查要求\\n- **功能审核**: 每次功能开发/修复必须审核最适合的单一节点\\n- **重复检测**: 严格避免重复实现、多次实现、多点修复\\n- **节点隔离**: transformer看不到预处理节点，不可跨节点修复\\n- **立即修改**: 发现违规立即停止，无条件重构到正确节点\\n\\n#### 💡 实施指导\\n```\\n✅ 正确: 在单一最适合的节点实现功能\\n❌ 错误: 跨多个节点实现同一功能\\n❌ 错误: 在transformer中修复预处理问题\\n❌ 错误: 重复实现已有逻辑\\n```\\n\\n**详细规则**: 参见 [📄 架构设计规则](.claude/rules/architecture-rules.md) 中的\\\"流水线跨节点耦合约束\\\"章节\\n\\n### 📊 完整交付报告体系强制约束 - P0级强制约束 (COMPLETE DELIVERY REPORT SYSTEM CONSTRAINT)\\n\\n⚠️ **最高优先级交付约束 - 违反将立即阻止交付**\\n\\n#### 🔒 绝对禁令\\n**交付前必须有完整的交付报告体系** - 这是P0级强制约束，与硬编码和Fallback同等重要\\n\\n#### 📋 强制交付报告要求\\n每次流水线交付必须包含以下完整报告体系：\\n\\n##### 🧪 1. 单元测试报告 (MANDATORY)\\n- **输入层模块**: Anthropic/OpenAI处理器、请求验证、速率限制、认证验证\\n- **路由层模块**: Provider选择、模型映射、负载均衡、健康检查、故障转移  \\n- **预处理器模块**: 统一补丁系统、格式兼容性、条件匹配逻辑\\n- **Transformer模块**: 协议转换器、响应转换器、流式处理器、工具调用处理器\\n- **Provider模块**: 各Provider连接、工厂模式、连接管理\\n- **输出层模块**: 响应格式化、错误处理、**Finish Reason完整路由**\\n\\n##### 🏗️ 2. 六层架构单层黑盒测试报告 (MANDATORY)  \\n- **客户端接入层**: HTTP API、认证、速率限制、请求验证、错误响应\\n- **路由决策层**: 类别路由、Provider选择、负载均衡、故障转移、模型映射\\n- **预处理层**: 格式兼容性、补丁系统、模型特定修复、请求转换\\n- **协议转换层**: OpenAI/Anthropic/Gemini协议、工具调用格式、流式协议\\n- **Provider连接层**: 各Provider连接、连接池管理\\n- **响应后处理层**: 响应格式、错误处理、Finish reason映射、Token计算\\n\\n##### 🌐 3. 端到端测试报告 (MANDATORY) - 真实连接测试\\n- **简单对话**: 单轮对话、Provider切换、错误恢复、流式传输、性能基准\\n- **工具调用**: 函数调用、工具定义传输、执行结果、错误处理、复杂场景  \\n- **多轮多工具**: 多轮上下文、工具链执行、内存管理、会话持久化、复杂工作流\\n\\n⚠️ **端到端测试强制要求**:\\n- **必须真实连接**: `rcc code --port <端口号>` 连接目标服务端口\\n- **禁止模拟测试**: 不可使用mock、stub或模拟响应\\n- **禁止绕过连接**: 不可简化或跳过真实连接环节\\n- **完整链路验证**: 必须验证",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 8647,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.351Z",
      "dataSize": 4495
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.352Z",
    "data": {
      "rawLine": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": 123,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": {
        "level": "error",
        "message": "        \"description\": \"Reads a file from the local filesystem. You can access any file directly by using this tool.\\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\\n\\nUsage:\\n- The file_path parameter must be an absolute path, not a relative path\\n- By default, it reads up to 2000 lines starting from the beginning of the file\\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\\n- Any lines longer than 2000 characters will be truncated\\n- Results are returned using cat -n format, with line numbers starting at 1\\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\\n- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\\n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\",",
        "stack": null
      },
      "performance": {
        "duration": null,
        "memory": null,
        "cpu": null
      }
    },
    "metadata": {
      "lineNumber": 8869,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.352Z",
      "dataSize": 1727
    }
  },
  {
    "type": "unstructured",
    "providerProtocol": "anthropic",
    "timestamp": "2025-08-11T06:12:11.352Z",
    "data": {
      "rawLine": "        \"description\": \"\\n- Allows Claude to search the web and use the results to inform responses\\n- Provides up-to-date information for current events and recent data\\n- Returns search result information formatted as search result blocks\\n- Use this tool for accessing information beyond Claude's knowledge cutoff\\n- Searches are performed automatically within a single API call\\n\\nUsage notes:\\n  - Domain filtering is supported to include or block specific websites\\n  - Web search is only available in the US\\n  - Account for \\\"Today's date\\\" in <env>. For example, if <env> says \\\"Today's date: 2025-07-01\\\", and the user wants the latest docs, do not use 2024 in the search query. Use 2025.\\n\",",
      "timestamp": null,
      "request": null,
      "response": {
        "status": null,
        "headers": null,
        "body": null,
        "duration": null
      },
      "error": null,
      "performance": null
    },
    "metadata": {
      "lineNumber": 9168,
      "fileName": "client-connection-test.log",
      "extractedAt": "2025-08-11T06:12:11.352Z",
      "dataSize": 702
    }
  }
]