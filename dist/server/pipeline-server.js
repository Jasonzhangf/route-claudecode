"use strict";
/**
 * PipelineÈõÜÊàêHTTPÊúçÂä°Âô®
 *
 * Â∞ÜPipelineÁÆ°ÁêÜÁ≥ªÁªüÈõÜÊàêÂà∞HTTPÊúçÂä°Âô®‰∏≠ÔºåÂÆûÁé∞ÂÆåÊï¥ÁöÑËØ∑Ê±ÇÂ§ÑÁêÜÊµÅÁ®ã
 *
 * @author Jason Zhang
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PipelineServer = void 0;
const http_server_1 = require("./http-server");
const pipeline_manager_1 = require("../pipeline/pipeline-manager");
const pipeline_factory_1 = require("../pipeline/pipeline-factory");
const module_registry_1 = require("../pipeline/module-registry");
const middleware_1 = require("../middleware");
const events_1 = require("events");
/**
 * PipelineÈõÜÊàêHTTPÊúçÂä°Âô®
 * ‰ΩøÁî®ÁªÑÂêàËÄåÈùûÁªßÊâøÁöÑÊñπÂºèÈõÜÊàêHTTPServerÂäüËÉΩ
 */
class PipelineServer extends events_1.EventEmitter {
    httpServer;
    pipelineManager;
    pipelineConfigs;
    serverConfig;
    constructor(config) {
        super();
        this.serverConfig = config;
        this.pipelineConfigs = config.pipelines || [];
        // ‰ΩøÁî®ÁªÑÂêàÔºöÂàõÂª∫HTTPServerÂÆû‰æã
        this.httpServer = new http_server_1.HTTPServer(config);
        // ËΩ¨ÂèëHTTPServerÁöÑ‰∫ã‰ª∂Âà∞PipelineServer
        this.httpServer.on('error', (error) => this.emit('error', error));
        this.httpServer.on('started', (data) => this.emit('started', data));
        this.httpServer.on('stopped', () => this.emit('stopped'));
        // ÂàùÂßãÂåñPipelineÁÆ°ÁêÜÂô®
        const moduleRegistry = new module_registry_1.ModuleRegistry();
        const factory = new pipeline_factory_1.StandardPipelineFactoryImpl(moduleRegistry);
        this.pipelineManager = new pipeline_manager_1.PipelineManager(factory);
        this.initializePipelineRoutes();
        this.initializeMiddleware();
    }
    /**
     * ÂàùÂßãÂåñPipelineÁõ∏ÂÖ≥Ë∑ØÁî±
     */
    initializePipelineRoutes() {
        // AnthropicÂÖºÂÆπÁ´ØÁÇπ - ‰ΩøÁî®PipelineÂ§ÑÁêÜ
        this.httpServer.addRoute('POST', '/v1/messages', async (req, res) => {
            await this.handleAnthropicRequest(req, res);
        });
        // OpenAIÂÖºÂÆπÁ´ØÁÇπ - ‰ΩøÁî®PipelineÂ§ÑÁêÜ
        this.httpServer.addRoute('POST', '/v1/chat/completions', async (req, res) => {
            await this.handleOpenAIRequest(req, res);
        });
        // GeminiÂÖºÂÆπÁ´ØÁÇπ - ‰ΩøÁî®PipelineÂ§ÑÁêÜ
        this.httpServer.addRoute('POST', '/v1beta/models/:model/generateContent', async (req, res) => {
            await this.handleGeminiRequest(req, res);
        });
        // Áªü‰∏ÄPipelineÁ´ØÁÇπ
        this.httpServer.addRoute('POST', '/v1/pipeline/:pipelineId', async (req, res) => {
            await this.handlePipelineRequest(req, res);
        });
        // PipelineÁÆ°ÁêÜÁ´ØÁÇπ
        this.httpServer.addRoute('GET', '/v1/pipelines', async (req, res) => {
            await this.handleGetPipelines(req, res);
        });
        this.httpServer.addRoute('GET', '/v1/pipelines/:pipelineId/status', async (req, res) => {
            await this.handleGetPipelineStatus(req, res);
        });
        this.httpServer.addRoute('POST', '/v1/pipelines/:pipelineId/start', async (req, res) => {
            await this.handleStartPipeline(req, res);
        });
        this.httpServer.addRoute('POST', '/v1/pipelines/:pipelineId/stop', async (req, res) => {
            await this.handleStopPipeline(req, res);
        });
    }
    /**
     * ÂàùÂßãÂåñ‰∏≠Èó¥‰ª∂
     */
    initializeMiddleware() {
        // CORS‰∏≠Èó¥‰ª∂
        if (this.serverConfig.enableCors !== false) {
            this.httpServer.use((0, middleware_1.cors)({
                origin: true,
                credentials: true,
                methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
                allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
            }));
        }
        // Êó•Âøó‰∏≠Èó¥‰ª∂
        this.httpServer.use((0, middleware_1.logger)({
            level: this.serverConfig.logLevel === 'debug' ? 2 : 1,
            format: 'detailed'
        }));
        // ËÆ§ËØÅ‰∏≠Èó¥‰ª∂ (ÂèØÈÄâ)
        if (this.serverConfig.enableAuth) {
            this.httpServer.use((0, middleware_1.authentication)({
                required: false,
                apiKeyHeader: 'Authorization'
            }));
        }
        // ËØ∑Ê±ÇÈ™åËØÅ‰∏≠Èó¥‰ª∂
        if (this.serverConfig.enableValidation !== false) {
            this.httpServer.use((0, middleware_1.validation)({
                maxBodySize: this.serverConfig.maxRequestSize || 10 * 1024 * 1024,
                validateContentType: true
            }));
        }
        // ÈÄüÁéáÈôêÂà∂‰∏≠Èó¥‰ª∂
        this.httpServer.use((0, middleware_1.rateLimit)({
            maxRequests: 1000,
            windowMs: 60000,
            message: 'Too many requests from this IP'
        }));
    }
    /**
     * ÂêØÂä®ÊúçÂä°Âô®Âπ∂ÂàùÂßãÂåñÊâÄÊúâPipeline
     */
    async start() {
        // ÂÖàÂàõÂª∫ÂíåÂêØÂä®ÊâÄÊúâPipeline
        await this.initializePipelines();
        // ÂêØÂä®HTTPÊúçÂä°Âô®
        await this.httpServer.start();
        // ËÆæÁΩÆPipeline‰∫ã‰ª∂ÁõëÂê¨
        this.setupPipelineEventListeners();
        console.log(`üéØ Pipeline Server started with ${this.pipelineConfigs.length} pipelines`);
    }
    /**
     * ÂÅúÊ≠¢ÊúçÂä°Âô®Âπ∂Ê∏ÖÁêÜPipelineËµÑÊ∫ê
     */
    async stop() {
        // ÂÅúÊ≠¢ÊâÄÊúâPipeline
        await this.cleanupPipelines();
        // ÂÅúÊ≠¢HTTPÊúçÂä°Âô®
        await this.httpServer.stop();
        console.log('üõë Pipeline Server stopped');
    }
    /**
     * ÂàùÂßãÂåñÊâÄÊúâPipeline
     */
    async initializePipelines() {
        console.log(`üîß Initializing ${this.pipelineConfigs.length} pipelines...`);
        for (const config of this.pipelineConfigs) {
            try {
                const pipelineId = await this.pipelineManager.createPipeline(config);
                const pipeline = this.pipelineManager.getPipeline(pipelineId);
                if (pipeline) {
                    await pipeline.start();
                    console.log(`‚úÖ Pipeline ${config.name} (${pipelineId}) initialized successfully`);
                }
            }
            catch (error) {
                console.error(`‚ùå Failed to initialize pipeline ${config.name}:`, error);
                throw error;
            }
        }
    }
    /**
     * Ê∏ÖÁêÜÊâÄÊúâPipeline
     */
    async cleanupPipelines() {
        const pipelines = this.pipelineManager.getAllPipelines();
        for (const [pipelineId, pipeline] of pipelines) {
            try {
                await pipeline.stop();
                await this.pipelineManager.destroyPipeline(pipelineId);
                console.log(`üßπ Pipeline ${pipelineId} cleaned up`);
            }
            catch (error) {
                console.error(`‚ùå Failed to cleanup pipeline ${pipelineId}:`, error);
            }
        }
    }
    /**
     * ËÆæÁΩÆPipeline‰∫ã‰ª∂ÁõëÂê¨
     */
    setupPipelineEventListeners() {
        this.pipelineManager.on('executionStarted', (data) => {
            if (this.serverConfig.debug) {
                console.log(`üèÉ Pipeline execution started: ${data.pipelineId} (${data.executionId})`);
            }
        });
        this.pipelineManager.on('executionCompleted', (data) => {
            if (this.serverConfig.debug) {
                console.log(`‚úÖ Pipeline execution completed: ${data.executionResult.executionId} in ${data.executionResult.performance.totalTime}ms`);
            }
        });
        this.pipelineManager.on('executionFailed', (data) => {
            console.error(`‚ùå Pipeline execution failed: ${data.executionResult.executionId}`, data.executionResult.error);
        });
    }
    /**
     * Â§ÑÁêÜAnthropicÊ†ºÂºèËØ∑Ê±Ç
     */
    async handleAnthropicRequest(req, res) {
        const requestBody = req.body;
        if (!requestBody || !requestBody.messages) {
            res.statusCode = 400;
            res.body = {
                error: 'Bad Request',
                message: 'Invalid request format. Expected Anthropic messages format.'
            };
            return;
        }
        // Êü•ÊâæÂêàÈÄÇÁöÑAnthropic Pipeline
        const pipeline = this.findPipelineByProtocol('anthropic', requestBody.model);
        if (!pipeline) {
            res.statusCode = 503;
            res.body = {
                error: 'Service Unavailable',
                message: 'No available Anthropic pipeline found'
            };
            return;
        }
        try {
            const executionContext = {
                requestId: req.id,
                priority: 'normal',
                debug: this.serverConfig.debug,
                metadata: {
                    protocol: 'anthropic',
                    model: requestBody.model,
                    clientInfo: req.headers['user-agent']
                }
            };
            const result = await this.pipelineManager.executePipeline(pipeline.getId(), requestBody, executionContext);
            res.body = result.result;
            res.headers['X-Pipeline-ID'] = pipeline.getId();
            res.headers['X-Execution-ID'] = result.executionId;
            res.headers['X-Processing-Time'] = `${result.performance.totalTime}ms`;
        }
        catch (error) {
            console.error('Anthropic request processing failed:', error);
            res.statusCode = 500;
            res.body = {
                error: 'Internal Server Error',
                message: 'Pipeline execution failed'
            };
        }
    }
    /**
     * Â§ÑÁêÜOpenAIÊ†ºÂºèËØ∑Ê±Ç
     */
    async handleOpenAIRequest(req, res) {
        const requestBody = req.body;
        if (!requestBody || !requestBody.messages) {
            res.statusCode = 400;
            res.body = {
                error: 'Bad Request',
                message: 'Invalid request format. Expected OpenAI chat completions format.'
            };
            return;
        }
        // Êü•ÊâæÂêàÈÄÇÁöÑOpenAI Pipeline
        const pipeline = this.findPipelineByProtocol('openai', requestBody.model);
        if (!pipeline) {
            res.statusCode = 503;
            res.body = {
                error: 'Service Unavailable',
                message: 'No available OpenAI pipeline found'
            };
            return;
        }
        try {
            const executionContext = {
                requestId: req.id,
                priority: 'normal',
                debug: this.serverConfig.debug,
                metadata: {
                    protocol: 'openai',
                    model: requestBody.model,
                    clientInfo: req.headers['user-agent']
                }
            };
            const result = await this.pipelineManager.executePipeline(pipeline.getId(), requestBody, executionContext);
            res.body = result.result;
            res.headers['X-Pipeline-ID'] = pipeline.getId();
            res.headers['X-Execution-ID'] = result.executionId;
            res.headers['X-Processing-Time'] = `${result.performance.totalTime}ms`;
        }
        catch (error) {
            console.error('OpenAI request processing failed:', error);
            res.statusCode = 500;
            res.body = {
                error: 'Internal Server Error',
                message: 'Pipeline execution failed'
            };
        }
    }
    /**
     * Â§ÑÁêÜGeminiÊ†ºÂºèËØ∑Ê±Ç
     */
    async handleGeminiRequest(req, res) {
        const requestBody = req.body;
        const model = this.extractPathParam(req.url, '/v1beta/models/:model/generateContent', 'model');
        if (!requestBody || !requestBody.contents) {
            res.statusCode = 400;
            res.body = {
                error: 'Bad Request',
                message: 'Invalid request format. Expected Gemini generateContent format.'
            };
            return;
        }
        if (!model) {
            res.statusCode = 400;
            res.body = {
                error: 'Bad Request',
                message: 'Model parameter is required'
            };
            return;
        }
        // Êü•ÊâæÂêàÈÄÇÁöÑGemini Pipeline
        const pipeline = this.findPipelineByProtocol('gemini', model);
        if (!pipeline) {
            res.statusCode = 503;
            res.body = {
                error: 'Service Unavailable',
                message: 'No available Gemini pipeline found'
            };
            return;
        }
        try {
            const executionContext = {
                requestId: req.id,
                priority: 'normal',
                debug: this.serverConfig.debug,
                metadata: {
                    protocol: 'gemini',
                    model: model,
                    clientInfo: req.headers['user-agent']
                }
            };
            const result = await this.pipelineManager.executePipeline(pipeline.getId(), { ...requestBody, model }, executionContext);
            res.body = result.result;
            res.headers['X-Pipeline-ID'] = pipeline.getId();
            res.headers['X-Execution-ID'] = result.executionId;
            res.headers['X-Processing-Time'] = `${result.performance.totalTime}ms`;
        }
        catch (error) {
            console.error('Gemini request processing failed:', error);
            res.statusCode = 500;
            res.body = {
                error: 'Internal Server Error',
                message: 'Pipeline execution failed'
            };
        }
    }
    /**
     * Â§ÑÁêÜÁõ¥Êé•PipelineËØ∑Ê±Ç
     */
    async handlePipelineRequest(req, res) {
        const pipelineId = this.extractPathParam(req.url, '/v1/pipeline/:pipelineId', 'pipelineId');
        if (!pipelineId) {
            res.statusCode = 400;
            res.body = {
                error: 'Bad Request',
                message: 'Pipeline ID is required'
            };
            return;
        }
        const pipeline = this.pipelineManager.getPipeline(pipelineId);
        if (!pipeline) {
            res.statusCode = 404;
            res.body = {
                error: 'Not Found',
                message: `Pipeline ${pipelineId} not found`
            };
            return;
        }
        try {
            const executionContext = {
                requestId: req.id,
                priority: 'normal',
                debug: this.serverConfig.debug,
                metadata: {
                    direct: true,
                    clientInfo: req.headers['user-agent']
                }
            };
            const result = await this.pipelineManager.executePipeline(pipelineId, req.body, executionContext);
            res.body = {
                success: true,
                executionId: result.executionId,
                result: result.result,
                performance: result.performance
            };
        }
        catch (error) {
            console.error('Direct pipeline request failed:', error);
            res.statusCode = 500;
            res.body = {
                error: 'Internal Server Error',
                message: 'Pipeline execution failed'
            };
        }
    }
    /**
     * Ëé∑ÂèñÊâÄÊúâPipelineÁä∂ÊÄÅ
     */
    async handleGetPipelines(req, res) {
        const pipelineStatuses = this.pipelineManager.getAllPipelineStatus();
        res.body = {
            pipelines: pipelineStatuses,
            count: Object.keys(pipelineStatuses).length,
            server: this.getStatus()
        };
    }
    /**
     * Ëé∑ÂèñÁâπÂÆöPipelineÁä∂ÊÄÅ
     */
    async handleGetPipelineStatus(req, res) {
        const pipelineId = this.extractPathParam(req.url, '/v1/pipelines/:pipelineId/status', 'pipelineId');
        if (!pipelineId) {
            res.statusCode = 400;
            res.body = {
                error: 'Bad Request',
                message: 'Pipeline ID is required'
            };
            return;
        }
        const status = this.pipelineManager.getPipelineStatus(pipelineId);
        if (!status) {
            res.statusCode = 404;
            res.body = {
                error: 'Not Found',
                message: `Pipeline ${pipelineId} not found`
            };
            return;
        }
        res.body = status;
    }
    /**
     * ÂêØÂä®Pipeline
     */
    async handleStartPipeline(req, res) {
        const pipelineId = this.extractPathParam(req.url, '/v1/pipelines/:pipelineId/start', 'pipelineId');
        if (!pipelineId) {
            res.statusCode = 400;
            res.body = {
                error: 'Bad Request',
                message: 'Pipeline ID is required'
            };
            return;
        }
        const pipeline = this.pipelineManager.getPipeline(pipelineId);
        if (!pipeline) {
            res.statusCode = 404;
            res.body = {
                error: 'Not Found',
                message: `Pipeline ${pipelineId} not found`
            };
            return;
        }
        try {
            await pipeline.start();
            res.body = {
                success: true,
                message: `Pipeline ${pipelineId} started successfully`
            };
        }
        catch (error) {
            res.statusCode = 500;
            res.body = {
                error: 'Internal Server Error',
                message: error instanceof Error ? error.message : 'Failed to start pipeline'
            };
        }
    }
    /**
     * ÂÅúÊ≠¢Pipeline
     */
    async handleStopPipeline(req, res) {
        const pipelineId = this.extractPathParam(req.url, '/v1/pipelines/:pipelineId/stop', 'pipelineId');
        if (!pipelineId) {
            res.statusCode = 400;
            res.body = {
                error: 'Bad Request',
                message: 'Pipeline ID is required'
            };
            return;
        }
        const pipeline = this.pipelineManager.getPipeline(pipelineId);
        if (!pipeline) {
            res.statusCode = 404;
            res.body = {
                error: 'Not Found',
                message: `Pipeline ${pipelineId} not found`
            };
            return;
        }
        try {
            await pipeline.stop();
            res.body = {
                success: true,
                message: `Pipeline ${pipelineId} stopped successfully`
            };
        }
        catch (error) {
            res.statusCode = 500;
            res.body = {
                error: 'Internal Server Error',
                message: error instanceof Error ? error.message : 'Failed to stop pipeline'
            };
        }
    }
    /**
     * Ê†πÊçÆÂçèËÆÆÂíåÊ®°ÂûãÊü•ÊâæPipeline
     */
    findPipelineByProtocol(protocol, model) {
        const pipelines = this.pipelineManager.getAllPipelines();
        for (const [pipelineId, pipeline] of pipelines) {
            const status = pipeline.getStatus();
            if (status.status === 'running') {
                // ÁÆÄÂçïÂåπÈÖçÈÄªËæëÔºåÂèØ‰ª•Ê†πÊçÆÈúÄË¶ÅÊâ©Â±ï
                const pipelineProvider = pipeline.provider;
                const pipelineModel = pipeline.model;
                if (protocol === 'anthropic' && pipelineProvider.includes('anthropic')) {
                    if (!model || pipelineModel.includes(model) || model.includes(pipelineModel)) {
                        return pipeline;
                    }
                }
                else if (protocol === 'openai' && pipelineProvider.includes('openai')) {
                    if (!model || pipelineModel.includes(model) || model.includes(pipelineModel)) {
                        return pipeline;
                    }
                }
                else if (protocol === 'gemini' && pipelineProvider.includes('gemini')) {
                    if (!model || pipelineModel.includes(model) || model.includes(pipelineModel)) {
                        return pipeline;
                    }
                }
            }
        }
        return null;
    }
    /**
     * ÊèêÂèñË∑ØÂæÑÂèÇÊï∞
     */
    extractPathParam(url, pattern, paramName) {
        // ÁÆÄÂçïÂÆûÁé∞ÔºåÂéªÈô§Êü•ËØ¢ÂèÇÊï∞
        const cleanUrl = url?.split('?')[0];
        if (!cleanUrl) {
            return null;
        }
        // ËΩ¨Êç¢pattern‰∏∫Ê≠£ÂàôË°®ËææÂºè
        const regexPattern = pattern.replace(/:([^/]+)/g, '([^/]+)');
        const regex = new RegExp(`^${regexPattern}$`);
        const match = cleanUrl.match(regex);
        if (match) {
            // Êü•ÊâæÂèÇÊï∞‰ΩçÁΩÆ
            const paramIndex = pattern.split('/').findIndex(part => part === `:${paramName}`);
            if (paramIndex > 0 && match[paramIndex]) {
                return match[paramIndex];
            }
        }
        return null;
    }
    /**
     * Ëé∑ÂèñPipelineÁÆ°ÁêÜÂô®
     */
    getPipelineManager() {
        return this.pipelineManager;
    }
    /**
     * Ëé∑ÂèñPipelineÈÖçÁΩÆ
     */
    getPipelineConfigs() {
        return [...this.pipelineConfigs];
    }
    /**
     * Ëé∑ÂèñÊúçÂä°Âô®Áä∂ÊÄÅ
     * ÂßîÊâòÁªôHTTPServerÂπ∂Ê∑ªÂä†PipelineÁõ∏ÂÖ≥‰ø°ÊÅØ
     */
    getStatus() {
        const httpStatus = this.httpServer.getStatus();
        const pipelineStatuses = this.pipelineManager.getAllPipelineStatus();
        return {
            ...httpStatus,
            activePipelines: Object.keys(pipelineStatuses).length,
            pipelines: pipelineStatuses
        };
    }
    /**
     * Ê∑ªÂä†‰∏≠Èó¥‰ª∂ - ÂßîÊâòÁªôHTTPServer
     */
    use(middleware) {
        this.httpServer.use(middleware);
    }
    /**
     * Ê∑ªÂä†Ë∑ØÁî± - ÂßîÊâòÁªôHTTPServer
     */
    addRoute(method, path, handler, middleware) {
        this.httpServer.addRoute(method, path, handler, middleware);
    }
}
exports.PipelineServer = PipelineServer;
//# sourceMappingURL=pipeline-server.js.map