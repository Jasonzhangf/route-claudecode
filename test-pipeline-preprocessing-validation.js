/**
 * ÊµÅÊ∞¥Á∫øÈ¢ÑÂ§ÑÁêÜÈ™åËØÅÊµãËØï
 * 
 * ÁõÆÁöÑÔºöËØäÊñ≠ÈùûÊµÅÂºèËØ∑Ê±ÇÈ¢ÑÂ§ÑÁêÜÊ≠•È™§ÊòØÂê¶ÁúüÁöÑÁº∫Â§±
 * È™åËØÅÁÇπÔºö
 * 1. Ê£ÄÊü•ÈùûÊµÅÂºèËØ∑Ê±ÇÊòØÂê¶Ëß¶Âèë 'request-preprocessing' Êó•Âøó
 * 2. Ê£ÄÊü•ÊµÅÂºèËØ∑Ê±ÇÊòØÂê¶Ëß¶Âèë 'streaming-request-preprocessing' Êó•Âøó
 * 3. ÂØπÊØî‰∏§ÁßçËØ∑Ê±ÇË∑ØÂæÑÁöÑÈ¢ÑÂ§ÑÁêÜË°å‰∏∫Â∑ÆÂºÇ
 * 4. È™åËØÅ UnifiedPatchPreprocessor ÁöÑ shouldProcess() Âà§Êñ≠ÈÄªËæë
 */

const axios = require('axios');
const fs = require('fs');

// ÊµãËØïÈÖçÁΩÆ
const TEST_CONFIG = {
    serverUrl: 'http://localhost:5508', // ShuaiHong ÊúçÂä°Á´ØÂè£
    testModel: 'claude-4-sonnet',
    outputFile: '/tmp/pipeline-preprocessing-validation-results.json',
    logFile: '/tmp/pipeline-preprocessing-validation.log'
};

class PipelinePreprocessingValidator {
    constructor() {
        this.results = {
            timestamp: new Date().toISOString(),
            testSuite: 'Pipeline Preprocessing Validation',
            tests: [],
            summary: {
                totalTests: 0,
                passedTests: 0,
                failedTests: 0,
                preprocessingIssues: []
            }
        };
    }

    log(message, data = null) {
        const logEntry = `${new Date().toISOString()} - ${message}${data ? `: ${JSON.stringify(data, null, 2)}` : ''}`;
        console.log(logEntry);
        fs.appendFileSync(TEST_CONFIG.logFile, logEntry + '\n');
    }

    async testNonStreamingRequestPreprocessing() {
        this.log('üß™ Testing Non-streaming Request Preprocessing');
        
        try {
            const requestPayload = {
                model: TEST_CONFIG.testModel,
                max_tokens: 150,
                messages: [
                    {
                        role: 'user',
                        content: 'Hello, can you tell me the time using a tool call?'
                    }
                ],
                stream: false // ÊòéÁ°ÆÊåáÂÆöÈùûÊµÅÂºè
            };

            const startTime = Date.now();
            const response = await axios.post(`${TEST_CONFIG.serverUrl}/v1/messages`, requestPayload, {
                headers: {
                    'Content-Type': 'application/json'
                },
                timeout: 30000
            });

            const duration = Date.now() - startTime;
            
            const testResult = {
                testName: 'Non-streaming Request Preprocessing',
                status: 'PASSED',
                duration,
                details: {
                    requestSent: true,
                    responseReceived: response.status === 200,
                    responseStatus: response.status,
                    responseSize: JSON.stringify(response.data).length,
                    preprocessingExpected: true,
                    logIdentifier: 'request-preprocessing'
                },
                analysis: {
                    preprocessingStepExpected: 'request-preprocessing',
                    shouldAppearInLogs: true,
                    requestType: 'non-streaming',
                    model: requestPayload.model
                }
            };

            this.results.tests.push(testResult);
            this.results.summary.passedTests++;
            this.log('‚úÖ Non-streaming request completed successfully');
            
        } catch (error) {
            const testResult = {
                testName: 'Non-streaming Request Preprocessing',
                status: 'FAILED',
                error: error.message,
                details: {
                    errorCode: error.response?.status,
                    errorData: error.response?.data,
                    preprocessingExpected: true,
                    logIdentifier: 'request-preprocessing'
                }
            };

            this.results.tests.push(testResult);
            this.results.summary.failedTests++;
            this.log('‚ùå Non-streaming request failed', { error: error.message });
        }
    }

    async testStreamingRequestPreprocessing() {
        this.log('üß™ Testing Streaming Request Preprocessing');
        
        try {
            const requestPayload = {
                model: TEST_CONFIG.testModel,
                max_tokens: 150,
                messages: [
                    {
                        role: 'user',
                        content: 'Hello, can you tell me the time using a tool call?'
                    }
                ],
                stream: true // ÊòéÁ°ÆÊåáÂÆöÊµÅÂºè
            };

            const startTime = Date.now();
            const response = await axios.post(`${TEST_CONFIG.serverUrl}/v1/messages`, requestPayload, {
                headers: {
                    'Content-Type': 'application/json'
                },
                timeout: 30000,
                responseType: 'stream'
            });

            const duration = Date.now() - startTime;
            
            let streamData = '';
            let chunkCount = 0;
            
            response.data.on('data', (chunk) => {
                streamData += chunk.toString();
                chunkCount++;
            });

            await new Promise((resolve, reject) => {
                response.data.on('end', resolve);
                response.data.on('error', reject);
            });
            
            const testResult = {
                testName: 'Streaming Request Preprocessing',
                status: 'PASSED',
                duration,
                details: {
                    requestSent: true,
                    streamReceived: response.status === 200,
                    responseStatus: response.status,
                    chunkCount,
                    streamDataSize: streamData.length,
                    preprocessingExpected: true,
                    logIdentifier: 'streaming-request-preprocessing'
                },
                analysis: {
                    preprocessingStepExpected: 'streaming-request-preprocessing',
                    shouldAppearInLogs: true,
                    requestType: 'streaming',
                    model: requestPayload.model
                }
            };

            this.results.tests.push(testResult);
            this.results.summary.passedTests++;
            this.log('‚úÖ Streaming request completed successfully', { chunkCount });
            
        } catch (error) {
            const testResult = {
                testName: 'Streaming Request Preprocessing',
                status: 'FAILED',
                error: error.message,
                details: {
                    errorCode: error.response?.status,
                    errorData: error.response?.data,
                    preprocessingExpected: true,
                    logIdentifier: 'streaming-request-preprocessing'
                }
            };

            this.results.tests.push(testResult);
            this.results.summary.failedTests++;
            this.log('‚ùå Streaming request failed', { error: error.message });
        }
    }

    async testPreprocessingConfiguration() {
        this.log('üß™ Testing Preprocessing Configuration');
        
        try {
            // Ê£ÄÊü•ÊúçÂä°Âô®Áä∂ÊÄÅÂíåÈÖçÁΩÆ
            const statusResponse = await axios.get(`${TEST_CONFIG.serverUrl}/status`, {
                timeout: 10000
            });

            const configAnalysis = {
                serverRunning: true,
                debugEnabled: statusResponse.data.debug,
                providersCount: statusResponse.data.providers.length,
                preprocessingEnvironment: {
                    RCC_UNIFIED_PREPROCESSING: process.env.RCC_UNIFIED_PREPROCESSING,
                    RCC_PREPROCESSING_DEBUG: process.env.RCC_PREPROCESSING_DEBUG,
                    RCC_FORCE_ALL_INPUTS: process.env.RCC_FORCE_ALL_INPUTS
                }
            };

            const testResult = {
                testName: 'Preprocessing Configuration',
                status: 'PASSED',
                details: configAnalysis,
                analysis: {
                    preprocessingEnabled: process.env.RCC_UNIFIED_PREPROCESSING !== 'false',
                    debugMode: process.env.RCC_PREPROCESSING_DEBUG === 'true',
                    forceAllInputs: process.env.RCC_FORCE_ALL_INPUTS === 'true'
                }
            };

            this.results.tests.push(testResult);
            this.results.summary.passedTests++;
            this.log('‚úÖ Configuration analysis completed');
            
        } catch (error) {
            const testResult = {
                testName: 'Preprocessing Configuration',
                status: 'FAILED',
                error: error.message
            };

            this.results.tests.push(testResult);
            this.results.summary.failedTests++;
            this.log('‚ùå Configuration analysis failed', { error: error.message });
        }
    }

    async checkLogFiles() {
        this.log('üß™ Checking Log Files for Preprocessing Evidence');
        
        try {
            // Ê£ÄÊü•ÂèØËÉΩÁöÑÊó•ÂøóÊñá‰ª∂‰ΩçÁΩÆ
            const logPaths = [
                '/tmp/ccr-dev.log',
                `~/.route-claude-code/logs/port-${TEST_CONFIG.serverUrl.split(':').pop()}/`,
                `/tmp/rcc-${TEST_CONFIG.serverUrl.split(':').pop()}.log`
            ];

            const logAnalysis = {
                searchPatterns: [
                    'request-preprocessing',
                    'streaming-request-preprocessing', 
                    'UnifiedPatchPreprocessor',
                    'preprocessInput'
                ],
                foundEvidence: [],
                searchResults: {}
            };

            for (const pattern of logAnalysis.searchPatterns) {
                logAnalysis.searchResults[pattern] = {
                    pattern,
                    found: false,
                    locations: [],
                    count: 0
                };
            }

            // ËøôÈáåÂèØ‰ª•Êâ©Â±ïÂÆûÈôÖÁöÑÊó•ÂøóÊñá‰ª∂ÊêúÁ¥¢ÈÄªËæë
            // Áî±‰∫éÊó•ÂøóÊñá‰ª∂‰ΩçÁΩÆÂèØËÉΩÂèòÂåñÔºåÊèê‰æõÂàÜÊûêÊ°ÜÊû∂

            const testResult = {
                testName: 'Log File Analysis',
                status: 'INFO',
                details: logAnalysis,
                recommendations: [
                    'Check server logs for "request-preprocessing" patterns',
                    'Enable RCC_PREPROCESSING_DEBUG=true for detailed logging',
                    'Monitor both streaming and non-streaming request logs',
                    'Compare log patterns between working and failing requests'
                ]
            };

            this.results.tests.push(testResult);
            this.log('‚ÑπÔ∏è Log analysis framework prepared');
            
        } catch (error) {
            this.log('‚ö†Ô∏è Log analysis setup failed', { error: error.message });
        }
    }

    generateDiagnosticSummary() {
        this.log('üìä Generating Diagnostic Summary');
        
        // ÂàÜÊûêÈ¢ÑÂ§ÑÁêÜÈóÆÈ¢òÊ®°Âºè
        const streamingTest = this.results.tests.find(t => t.testName === 'Streaming Request Preprocessing');
        const nonStreamingTest = this.results.tests.find(t => t.testName === 'Non-streaming Request Preprocessing');
        const configTest = this.results.tests.find(t => t.testName === 'Preprocessing Configuration');

        const diagnosticSummary = {
            overallFindings: {
                streamingRequestWorks: streamingTest?.status === 'PASSED',
                nonStreamingRequestWorks: nonStreamingTest?.status === 'PASSED',
                configurationValid: configTest?.status === 'PASSED'
            },
            possibleIssues: [],
            recommendations: [],
            nextSteps: []
        };

        // Âü∫‰∫éÊµãËØïÁªìÊûúÁîüÊàêËØäÊñ≠
        if (!diagnosticSummary.overallFindings.nonStreamingRequestWorks) {
            diagnosticSummary.possibleIssues.push('Non-streaming request preprocessing may be failing');
            diagnosticSummary.recommendations.push('Enable RCC_PREPROCESSING_DEBUG=true');
            diagnosticSummary.recommendations.push('Check UnifiedPatchPreprocessor shouldProcess() logic');
        }

        if (!diagnosticSummary.overallFindings.streamingRequestWorks) {
            diagnosticSummary.possibleIssues.push('Streaming request preprocessing may be failing');
        }

        if (diagnosticSummary.overallFindings.streamingRequestWorks && 
            !diagnosticSummary.overallFindings.nonStreamingRequestWorks) {
            diagnosticSummary.possibleIssues.push('CRITICAL: Non-streaming preprocessing silent failure confirmed');
            diagnosticSummary.nextSteps.push('Investigate shouldProcess() conditions for input stage');
            diagnosticSummary.nextSteps.push('Check if forceAllInputs should be enabled by default');
        }

        if (diagnosticSummary.possibleIssues.length === 0) {
            diagnosticSummary.possibleIssues.push('Both preprocessing paths appear functional - issue may be in logging or observation');
            diagnosticSummary.recommendations.push('Check log pattern search methodology');
            diagnosticSummary.recommendations.push('Verify log file locations and access');
        }

        this.results.diagnosticSummary = diagnosticSummary;
        
        this.log('üìä Diagnostic Summary Generated', diagnosticSummary);
    }

    async runAllTests() {
        this.log('üöÄ Starting Pipeline Preprocessing Validation');
        this.results.summary.totalTests = 4;

        // Ê∏ÖÁ©∫‰πãÂâçÁöÑÊó•Âøó
        if (fs.existsSync(TEST_CONFIG.logFile)) {
            fs.unlinkSync(TEST_CONFIG.logFile);
        }

        await this.testPreprocessingConfiguration();
        await this.testNonStreamingRequestPreprocessing();
        await this.testStreamingRequestPreprocessing();
        await this.checkLogFiles();
        
        this.generateDiagnosticSummary();
        
        // ‰øùÂ≠òÁªìÊûú
        fs.writeFileSync(TEST_CONFIG.outputFile, JSON.stringify(this.results, null, 2));
        
        this.log('‚úÖ All tests completed', {
            totalTests: this.results.summary.totalTests,
            passed: this.results.summary.passedTests,
            failed: this.results.summary.failedTests,
            outputFile: TEST_CONFIG.outputFile
        });

        // ËæìÂá∫ÂÖ≥ÈîÆÂèëÁé∞
        console.log('\nüîç KEY FINDINGS:');
        this.results.diagnosticSummary.possibleIssues.forEach(issue => {
            console.log(`‚ùå ${issue}`);
        });
        
        console.log('\nüìã RECOMMENDATIONS:');
        this.results.diagnosticSummary.recommendations.forEach(rec => {
            console.log(`üí° ${rec}`);
        });

        console.log('\nüéØ NEXT STEPS:');
        this.results.diagnosticSummary.nextSteps.forEach(step => {
            console.log(`üîß ${step}`);
        });

        return this.results;
    }
}

// ËøêË°åÊµãËØï
async function main() {
    const validator = new PipelinePreprocessingValidator();
    
    try {
        await validator.runAllTests();
        process.exit(0);
    } catch (error) {
        console.error('üö® Test suite failed:', error.message);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = { PipelinePreprocessingValidator, TEST_CONFIG };